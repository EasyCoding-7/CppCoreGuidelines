


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="C++ 핵심 가이드라인 한글화 프로젝트">
      
      
        <link rel="canonical" href="http://www.cppkorea.org/CppCoreGuidelines/Expr/">
      
      
        <meta name="author" content="C++ Korea">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.4.0">
    
    
      
        <title>Expr - C++ 핵심 가이드라인</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.fe0cca5b.min.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nanum+Gothic:300,400,400i,700%7CNanum+Gothic+Coding&display=fallback">
        <style>body,input{font-family:"Nanum Gothic",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Nanum Gothic Coding",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#es" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-header-nav__button md-logo" aria-label="C++ 핵심 가이드라인">
      
  <img src="../images/logo.svg" alt="logo">

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            C++ 핵심 가이드라인
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Expr
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-nav__button md-logo" aria-label="C++ 핵심 가이드라인">
      
  <img src="../images/logo.svg" alt="logo">

    </a>
    C++ 핵심 가이드라인
  </label>
  
    <div class="md-nav__source">
      
<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../home/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Introduction
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Introduction" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Introduction
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Introduction/" title="In: 소개" class="md-nav__link">
      <a name="S-introduction"></a>In: 소개
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      References
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="References" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        References
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../References/" title="RF: 레퍼런스" class="md-nav__link">
      <a name="S-references"></a>RF: 레퍼런스
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Sections
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sections" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sections
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Architecture/" title="Architecture" class="md-nav__link">
      Architecture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Class/" title="Class" class="md-nav__link">
      Class
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Concurrency/" title="Concurrency" class="md-nav__link">
      Concurrency
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Const/" title="Const" class="md-nav__link">
      Const
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CPL/" title="C-Style" class="md-nav__link">
      C-Style
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Enum/" title="Enum" class="md-nav__link">
      Enum
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Errors/" title="Errors" class="md-nav__link">
      Errors
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Expr
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2z"/></svg>
        </span>
      </label>
    
    <a href="./" title="Expr" class="md-nav__link md-nav__link--active">
      Expr
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#es1" class="md-nav__link">
    ES.1: 다른 라이브러리나 "직접 짠 코드" 대신 표준 라이브러리를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.1: 다른 라이브러리나 "직접 짠 코드" 대신 표준 라이브러리를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#es2" class="md-nav__link">
    ES.2: 언어 기능을 바로 사용하기는 보다 적절히 추상화하라
  </a>
  
    <nav class="md-nav" aria-label="ES.2: 언어 기능을 바로 사용하기는 보다 적절히 추상화하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_1" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_1" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_1" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esdcl-declarations" class="md-nav__link">
    ES.dcl: 선언(Declarations)
  </a>
  
    <nav class="md-nav" aria-label="ES.dcl: 선언(Declarations)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es5-scope" class="md-nav__link">
    ES.5: 유효범위(scope)는 작게 유지하라
  </a>
  
    <nav class="md-nav" aria-label="ES.5: 유효범위(scope)는 작게 유지하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_2" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_2" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_2" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es6-for" class="md-nav__link">
    ES.6: for 문의 변수는 유효범위를 제한하기 위해 초기화와 조건 검사부분에서만 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.6: for 문의 변수는 유효범위를 제한하기 위해 초기화와 조건 검사부분에서만 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_3" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_3" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_3" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c17-example" class="md-nav__link">
    C++17 example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c17-enforcement-if-using-a-c17-compiler" class="md-nav__link">
    C++17 enforcement (if using a C++17 compiler)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es7" class="md-nav__link">
    ES.7: 일반적이거나 지역범위 변수들의 이름은 짧게, 그렇지 않다면 길게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.7: 일반적이거나 지역범위 변수들의 이름은 짧게, 그렇지 않다면 길게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_4" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_4" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_5" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_1" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_4" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es8" class="md-nav__link">
    ES.8: 비슷해보이는 이름은 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.8: 비슷해보이는 이름은 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_5" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_2" class="md-nav__link">
    Example; bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_3" class="md-nav__link">
    Example; bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_1" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_5" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es9-all_caps" class="md-nav__link">
    ES.9: ALL_CAPS 같은 이름을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.9: ALL_CAPS 같은 이름을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_6" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_6" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_6" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es10" class="md-nav__link">
    ES.10: 선언은 (오직) 하나의 이름을 선언해야 한다
  </a>
  
    <nav class="md-nav" aria-label="ES.10: 선언은 (오직) 하나의 이름을 선언해야 한다">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_7" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_4" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_2" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_3" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_7" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_8" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_9" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_7" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es11-auto" class="md-nav__link">
    ES.11: 타입 이름의 불필요한 반복을 막을때는 auto를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.11: 타입 이름의 불필요한 반복을 막을때는 auto를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_8" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_10" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_11" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_4" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_12" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_1" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-c17" class="md-nav__link">
    Example (C++17)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_8" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es12" class="md-nav__link">
    ES.12: 이름을 덮어쓰지 않도록 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.12: 이름을 덮어쓰지 않도록 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_9" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_5" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_2" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_13" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_6" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_5" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_9" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es20" class="md-nav__link">
    ES.20: 항상 개체를 초기화하라
  </a>
  
    <nav class="md-nav" aria-label="ES.20: 항상 개체를 초기화하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_10" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_14" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_3" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_15" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_4" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_16" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_6" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_17" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_5" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_10" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es21" class="md-nav__link">
    ES.21: 사용할 필요가 없을 때 변수나 상수를 선언하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.21: 사용할 필요가 없을 때 변수나 상수를 선언하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_11" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_18" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_11" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es22" class="md-nav__link">
    ES.22: 변수를 초기화할 값이 생길 때까지 선언하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.22: 변수를 초기화할 값이 생길 때까지 선언하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_12" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_7" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_8" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_12" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es23" class="md-nav__link">
    ES.23: {} 초기화 문법을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.23: {} 초기화 문법을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_13" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_19" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_7" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_6" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_20" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_7" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_8" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_9" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_21" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_13" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es24-unique_ptrt" class="md-nav__link">
    ES.24: 포인터는 unique_ptr&lt;T&gt;에 담아라
  </a>
  
    <nav class="md-nav" aria-label="ES.24: 포인터는 unique_ptr&lt;T&gt;에 담아라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_14" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_22" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_14" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es25-const-constexpr" class="md-nav__link">
    ES.25: 값을 변경하지 않는다면 개체를 const 혹은 constexpr로 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.25: 값을 변경하지 않는다면 개체를 const 혹은 constexpr로 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_15" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_23" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_15" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es26" class="md-nav__link">
    ES.26: 서로 상관없는 목적에 하나의 변수를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.26: 서로 상관없는 목적에 하나의 변수를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_16" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_9" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_10" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_16" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es27-stdarray-stack_array" class="md-nav__link">
    ES.27: 스택에서 사용되는 배열은 std::array나 stack_array를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.27: 스택에서 사용되는 배열은 std::array나 stack_array를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_17" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_10" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_11" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_24" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_17" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es28-const" class="md-nav__link">
    ES.28: 복잡한 초기화, 특히 const 변수의 초기화에는 람다를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.28: 복잡한 초기화, 특히 const 변수의 초기화에는 람다를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_18" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_11" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_25" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_18" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es30-manipulate" class="md-nav__link">
    ES.30: 프로그램 텍스트를 다루기(manipulate) 위해 매크로를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.30: 프로그램 텍스트를 다루기(manipulate) 위해 매크로를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_19" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_12" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_12" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_13" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_19" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es31" class="md-nav__link">
    ES.31: 매크로를 상수나 "함수"에 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.31: 매크로를 상수나 "함수"에 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_20" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_13" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_20" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es32-all_caps" class="md-nav__link">
    ES.32: 모든 매크로는 ALL_CAPS 형태로 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.32: 모든 매크로는 ALL_CAPS 형태로 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_21" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_26" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_21" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es33" class="md-nav__link">
    ES.33: 매크로를 사용해야만 한다면, 고유한 이름을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.33: 매크로를 사용해야만 한다면, 고유한 이름을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_22" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_27" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_14" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_22" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es34-c-" class="md-nav__link">
     ES.34: (C-스타일의) 가변인자 함수를 정의하지 마라
  </a>
  
    <nav class="md-nav" aria-label=" ES.34: (C-스타일의) 가변인자 함수를 정의하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_23" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_28" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_15" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_23" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esexpr" class="md-nav__link">
    ES.expr: 표현식
  </a>
  
    <nav class="md-nav" aria-label="ES.expr: 표현식">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es40" class="md-nav__link">
    ES.40: 복잡한 표현식을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.40: 복잡한 표현식을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_24" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_29" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_16" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_17" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_30" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_24" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es41-parenthesize" class="md-nav__link">
    ES.41: 연산자 우선순위가 불분명하면, 소괄호를 사용하라(parenthesize)
  </a>
  
    <nav class="md-nav" aria-label="ES.41: 연산자 우선순위가 불분명하면, 소괄호를 사용하라(parenthesize)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_25" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_31" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_18" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_19" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_25" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es42" class="md-nav__link">
    ES.42: 포인터는 간단하고 직관적인 형태로 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.42: 포인터는 간단하고 직관적인 형태로 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_26" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_20" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_14" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_1" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_21" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_15" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_2" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_16" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_3" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_22" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_32" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_26" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es43" class="md-nav__link">
    ES.43: 평가 순서가 정의되지 않은 표현식은 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.43: 평가 순서가 정의되지 않은 표현식은 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_27" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_23" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_33" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_27" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es44" class="md-nav__link">
    ES.44: 함수 인자가 표현식 평가 순서의 영향을 받지 않게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.44: 함수 인자가 표현식 평가 순서의 영향을 받지 않게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_28" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_24" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_34" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_35" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_28" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es45-magic-constant" class="md-nav__link">
    ES.45: 이유를 알 수 없는 상수(magic constant)를 사용하지 마라; 상징적인 상수를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.45: 이유를 알 수 없는 상수(magic constant)를 사용하지 마라; 상징적인 상수를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_29" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_36" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_29" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es46" class="md-nav__link">
    ES.46: 타입 범위를 축소하는 변환을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.46: 타입 범위를 축소하는 변환을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_30" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_17" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_25" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_30" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es47-0-null-nullptr" class="md-nav__link">
    ES.47: 0 혹은 NULL보다는 nullptr를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.47: 0 혹은 NULL보다는 nullptr를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_31" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_37" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_31" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es48-cast" class="md-nav__link">
    ES.48: 타입 변환(cast)을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.48: 타입 변환(cast)을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_32" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_18" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_26" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_27" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_28" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_8" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternatives" class="md-nav__link">
    Alternatives
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_32" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es49-named-cast" class="md-nav__link">
    ES.49: 타입 변환을 사용해야만 한다면, 미리 정의된 방법으로 변환(named cast)하라
  </a>
  
    <nav class="md-nav" aria-label="ES.49: 타입 변환을 사용해야만 한다면, 미리 정의된 방법으로 변환(named cast)하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_33" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_38" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_29" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_30" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_33" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es50-const" class="md-nav__link">
    ES.50: const를 제거하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.50: const를 제거하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_34" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_19" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_39" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_9" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_40" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_34" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es55" class="md-nav__link">
    ES.55: 범위 검사가 필요없게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.55: 범위 검사가 필요없게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_35" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_41" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_35" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es56-stdmove" class="md-nav__link">
    ES.56: std::move()는 개체를 다른 유효범위로 명시적으로 옮겨야 할때만 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.56: std::move()는 개체를 다른 유효범위로 명시적으로 옮겨야 할때만 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_36" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#notes" class="md-nav__link">
    Notes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_20" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_42" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#notes_1" class="md-nav__link">
    Notes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_21" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_22" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_43" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_36" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es60-new-delete" class="md-nav__link">
    ES.60: 자원을 관리하는 함수 외부에서 new와 delete 사용을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.60: 자원을 관리하는 함수 외부에서 new와 delete 사용을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_37" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_31" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_23" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also_1" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_37" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es61-delete-delete" class="md-nav__link">
    ES.61: 배열은 delete[], 단일 개체는 delete를 사용해서 해제하라
  </a>
  
    <nav class="md-nav" aria-label="ES.61: 배열은 delete[], 단일 개체는 delete를 사용해서 해제하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_38" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_24" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_32" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_38" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es62" class="md-nav__link">
    ES.62: 서로 다른 배열에 대한 포인터를 비교하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.62: 서로 다른 배열에 대한 포인터를 비교하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_39" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_25" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_33" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_39" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es63-slice" class="md-nav__link">
    ES.63: 복사 손실(slice)이 없도록 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.63: 복사 손실(slice)이 없도록 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_40" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_44" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_1" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_40" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es64-te" class="md-nav__link">
    ES.64: 개체를 생성할 때는 T{e}표기를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.64: 개체를 생성할 때는 T{e}표기를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_41" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_45" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_34" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_35" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_36" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_10" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_41" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es65-invalid" class="md-nav__link">
    ES.65: 유효하지 않은(invalid) 포인터를 역참조하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.65: 유효하지 않은(invalid) 포인터를 역참조하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_42" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_37" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also_2" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_46" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_47" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_48" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_49" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_42" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esstmt-statement" class="md-nav__link">
    ES.stmt: 구문(statement)
  </a>
  
    <nav class="md-nav" aria-label="ES.stmt: 구문(statement)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es70-if-switch" class="md-nav__link">
    ES.70: 선택을 하는 경우에는 if구문보다는 switch구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.70: 선택을 하는 경우에는 if구문보다는 switch구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_43" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_50" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_43" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es71-for-for-" class="md-nav__link">
    ES.71: 가능하다면 일반 for구문 보다 범위기반 for-구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.71: 가능하다면 일반 for구문 보다 범위기반 for-구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_44" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_51" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_38" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_44" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es72-while-for-" class="md-nav__link">
    ES.72: 루프 변수가 있다면 while-구문보다 for-구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.72: 루프 변수가 있다면 while-구문보다 for-구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_45" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_52" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_26" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_45" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es73-for-while-" class="md-nav__link">
    ES.73: 루프 변수가 없다면 for-구문보다 while-구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.73: 루프 변수가 없다면 for-구문보다 while-구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_46" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_53" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_46" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es74-for-" class="md-nav__link">
    ES.74: 루프 변수는 for-구문의 초기화 부분에서 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.74: 루프 변수는 for-구문의 초기화 부분에서 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_47" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_54" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-dont" class="md-nav__link">
    Example, don't
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also_3" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_55" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_47" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#discussion" class="md-nav__link">
    Discussion
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es75-do-" class="md-nav__link">
    ES.75: do-구문을 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.75: do-구문을 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_48" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_56" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_39" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_48" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es76-goto" class="md-nav__link">
    ES.76: goto를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.76: goto를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_49" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_11" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_27" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_49" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es77-break-continue" class="md-nav__link">
    ES.77: break와 continue의 사용을 최소화하라
  </a>
  
    <nav class="md-nav" aria-label="ES.77: break와 continue의 사용을 최소화하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_50" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_57" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_2" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_40" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_50" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es78-case-break" class="md-nav__link">
    ES.78: 내용이 있는 case는 break하라
  </a>
  
    <nav class="md-nav" aria-label="ES.78: 내용이 있는 case는 break하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_51" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_58" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_41" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_51" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es79-default" class="md-nav__link">
    ES.79: (오직) 일반적인 경우를 처리하기 위해서 default를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.79: (오직) 일반적인 경우를 처리하기 위해서 default를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_52" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_59" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_60" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_52" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es84" class="md-nav__link">
    ES.84: 이름이 없는 지역변수는 선언(하려고)하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.84: 이름이 없는 지역변수는 선언(하려고)하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_53" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_28" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_42" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_53" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es85" class="md-nav__link">
    ES.85: 비어있는 구문은 눈에띄게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.85: 비어있는 구문은 눈에띄게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_54" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_61" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_54" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es86-for-body" class="md-nav__link">
    ES.86: for 반복문(body) 안에서 루프 변수를 변경하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.86: for 반복문(body) 안에서 루프 변수를 변경하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_55" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_62" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_55" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es87" class="md-nav__link">
    ES.87: 조건에 불필요한 ==나 !=를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.87: 조건에 불필요한 ==나 !=를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_56" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_63" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_64" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_65" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_43" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_29" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_44" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_56" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arithmetic" class="md-nav__link">
    산술연산(Arithmetic)
  </a>
  
    <nav class="md-nav" aria-label="산술연산(Arithmetic)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es100" class="md-nav__link">
    ES.100: 부호가 있는 타입과 없는 타입을 함께 연산하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.100: 부호가 있는 타입과 없는 타입을 함께 연산하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_57" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_66" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_45" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_57" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es101-unsigned" class="md-nav__link">
    ES.101: 비트 조작시에는 부호가 없는(unsigned) 타입을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.101: 비트 조작시에는 부호가 없는(unsigned) 타입을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_58" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_67" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_46" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_58" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es102-signed" class="md-nav__link">
    ES.102: 연산에는 부호가 있는(signed) 타입을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.102: 연산에는 부호가 있는(signed) 타입을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_59" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_68" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_12" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_69" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_59" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es103-overflow" class="md-nav__link">
    ES.103: Overflow가 발생하지 않게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.103: Overflow가 발생하지 않게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_60" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_30" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_31" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_32" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_13" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_3" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_60" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es104-underflow" class="md-nav__link">
    ES.104: Underflow가 발생하지 않게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.104: Underflow가 발생하지 않게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_61" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_33" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_14" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_61" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es105-0" class="md-nav__link">
    ES.105: 0으로 나누지 않도록 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.105: 0으로 나누지 않도록 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_62" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_47" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_34" class="md-nav__link">
    Example; bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_4" class="md-nav__link">
    Example; good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_4" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_62" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es106-unsigned" class="md-nav__link">
    ES.106: 음수값을 막으려고 unsigned를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.106: 음수값을 막으려고 unsigned를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_63" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_70" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_71" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternatives_1" class="md-nav__link">
    Alternatives
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_48" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_63" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es107-unsigned-gslindex" class="md-nav__link">
    ES.107: 배열 접근에는 unsigned를 쓰지 말고 gsl::index를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.107: 배열 접근에는 unsigned를 쓰지 말고 gsl::index를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_64" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_35" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_5" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_49" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_72" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_73" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternatives_2" class="md-nav__link">
    Alternatives
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_64" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Functions/" title="Functions" class="md-nav__link">
      Functions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Glossary/" title="Glossary" class="md-nav__link">
      Glossary
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../GSL/" title="GSL" class="md-nav__link">
      GSL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interfaces/" title="Interfaces" class="md-nav__link">
      Interfaces
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Naming/" title="Naming" class="md-nav__link">
      Naming
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Not/" title="Not-Rule" class="md-nav__link">
      Not-Rule
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Performance/" title="Performance" class="md-nav__link">
      Performance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Philosophy/" title="Philosophy" class="md-nav__link">
      Philosophy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Profile/" title="Profile" class="md-nav__link">
      Profile
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Resource/" title="Resource" class="md-nav__link">
      Resource
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../SL/" title="Standard Library" class="md-nav__link">
      Standard Library
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Source/" title="Source" class="md-nav__link">
      Source
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Templates/" title="Templates" class="md-nav__link">
      Templates
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Unclassified/" title="Unclassified" class="md-nav__link">
      Unclassified
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Appendix
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Appendix" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Appendix
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Modernizing/" title="Modernizing" class="md-nav__link">
      Modernizing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Tools/" title="Tools" class="md-nav__link">
      Tools
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#es1" class="md-nav__link">
    ES.1: 다른 라이브러리나 "직접 짠 코드" 대신 표준 라이브러리를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.1: 다른 라이브러리나 "직접 짠 코드" 대신 표준 라이브러리를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#es2" class="md-nav__link">
    ES.2: 언어 기능을 바로 사용하기는 보다 적절히 추상화하라
  </a>
  
    <nav class="md-nav" aria-label="ES.2: 언어 기능을 바로 사용하기는 보다 적절히 추상화하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_1" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_1" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_1" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esdcl-declarations" class="md-nav__link">
    ES.dcl: 선언(Declarations)
  </a>
  
    <nav class="md-nav" aria-label="ES.dcl: 선언(Declarations)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es5-scope" class="md-nav__link">
    ES.5: 유효범위(scope)는 작게 유지하라
  </a>
  
    <nav class="md-nav" aria-label="ES.5: 유효범위(scope)는 작게 유지하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_2" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_2" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_2" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es6-for" class="md-nav__link">
    ES.6: for 문의 변수는 유효범위를 제한하기 위해 초기화와 조건 검사부분에서만 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.6: for 문의 변수는 유효범위를 제한하기 위해 초기화와 조건 검사부분에서만 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_3" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_3" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_3" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c17-example" class="md-nav__link">
    C++17 example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c17-enforcement-if-using-a-c17-compiler" class="md-nav__link">
    C++17 enforcement (if using a C++17 compiler)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es7" class="md-nav__link">
    ES.7: 일반적이거나 지역범위 변수들의 이름은 짧게, 그렇지 않다면 길게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.7: 일반적이거나 지역범위 변수들의 이름은 짧게, 그렇지 않다면 길게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_4" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_4" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_5" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_1" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_4" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es8" class="md-nav__link">
    ES.8: 비슷해보이는 이름은 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.8: 비슷해보이는 이름은 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_5" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_2" class="md-nav__link">
    Example; bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_3" class="md-nav__link">
    Example; bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_1" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_5" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es9-all_caps" class="md-nav__link">
    ES.9: ALL_CAPS 같은 이름을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.9: ALL_CAPS 같은 이름을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_6" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_6" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_6" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es10" class="md-nav__link">
    ES.10: 선언은 (오직) 하나의 이름을 선언해야 한다
  </a>
  
    <nav class="md-nav" aria-label="ES.10: 선언은 (오직) 하나의 이름을 선언해야 한다">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_7" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_4" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_2" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_3" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_7" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_8" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_9" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_7" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es11-auto" class="md-nav__link">
    ES.11: 타입 이름의 불필요한 반복을 막을때는 auto를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.11: 타입 이름의 불필요한 반복을 막을때는 auto를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_8" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_10" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_11" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_4" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_12" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_1" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-c17" class="md-nav__link">
    Example (C++17)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_8" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es12" class="md-nav__link">
    ES.12: 이름을 덮어쓰지 않도록 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.12: 이름을 덮어쓰지 않도록 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_9" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_5" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_2" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_13" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_6" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_5" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_9" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es20" class="md-nav__link">
    ES.20: 항상 개체를 초기화하라
  </a>
  
    <nav class="md-nav" aria-label="ES.20: 항상 개체를 초기화하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_10" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_14" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_3" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_15" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_4" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_16" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_6" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_17" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_5" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_10" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es21" class="md-nav__link">
    ES.21: 사용할 필요가 없을 때 변수나 상수를 선언하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.21: 사용할 필요가 없을 때 변수나 상수를 선언하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_11" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_18" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_11" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es22" class="md-nav__link">
    ES.22: 변수를 초기화할 값이 생길 때까지 선언하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.22: 변수를 초기화할 값이 생길 때까지 선언하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_12" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_7" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_8" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_12" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es23" class="md-nav__link">
    ES.23: {} 초기화 문법을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.23: {} 초기화 문법을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_13" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_19" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_7" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_6" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_20" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_7" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_8" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_9" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_21" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_13" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es24-unique_ptrt" class="md-nav__link">
    ES.24: 포인터는 unique_ptr&lt;T&gt;에 담아라
  </a>
  
    <nav class="md-nav" aria-label="ES.24: 포인터는 unique_ptr&lt;T&gt;에 담아라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_14" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_22" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_14" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es25-const-constexpr" class="md-nav__link">
    ES.25: 값을 변경하지 않는다면 개체를 const 혹은 constexpr로 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.25: 값을 변경하지 않는다면 개체를 const 혹은 constexpr로 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_15" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_23" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_15" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es26" class="md-nav__link">
    ES.26: 서로 상관없는 목적에 하나의 변수를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.26: 서로 상관없는 목적에 하나의 변수를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_16" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_9" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_10" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_16" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es27-stdarray-stack_array" class="md-nav__link">
    ES.27: 스택에서 사용되는 배열은 std::array나 stack_array를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.27: 스택에서 사용되는 배열은 std::array나 stack_array를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_17" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_10" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_11" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_24" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_17" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es28-const" class="md-nav__link">
    ES.28: 복잡한 초기화, 특히 const 변수의 초기화에는 람다를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.28: 복잡한 초기화, 특히 const 변수의 초기화에는 람다를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_18" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_11" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_25" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_18" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es30-manipulate" class="md-nav__link">
    ES.30: 프로그램 텍스트를 다루기(manipulate) 위해 매크로를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.30: 프로그램 텍스트를 다루기(manipulate) 위해 매크로를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_19" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_12" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_12" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_13" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_19" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es31" class="md-nav__link">
    ES.31: 매크로를 상수나 "함수"에 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.31: 매크로를 상수나 "함수"에 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_20" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_13" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_20" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es32-all_caps" class="md-nav__link">
    ES.32: 모든 매크로는 ALL_CAPS 형태로 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.32: 모든 매크로는 ALL_CAPS 형태로 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_21" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_26" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_21" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es33" class="md-nav__link">
    ES.33: 매크로를 사용해야만 한다면, 고유한 이름을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.33: 매크로를 사용해야만 한다면, 고유한 이름을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_22" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_27" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_14" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_22" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es34-c-" class="md-nav__link">
     ES.34: (C-스타일의) 가변인자 함수를 정의하지 마라
  </a>
  
    <nav class="md-nav" aria-label=" ES.34: (C-스타일의) 가변인자 함수를 정의하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_23" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_28" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_15" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_23" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esexpr" class="md-nav__link">
    ES.expr: 표현식
  </a>
  
    <nav class="md-nav" aria-label="ES.expr: 표현식">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es40" class="md-nav__link">
    ES.40: 복잡한 표현식을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.40: 복잡한 표현식을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_24" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_29" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_16" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_17" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_30" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_24" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es41-parenthesize" class="md-nav__link">
    ES.41: 연산자 우선순위가 불분명하면, 소괄호를 사용하라(parenthesize)
  </a>
  
    <nav class="md-nav" aria-label="ES.41: 연산자 우선순위가 불분명하면, 소괄호를 사용하라(parenthesize)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_25" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_31" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_18" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_19" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_25" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es42" class="md-nav__link">
    ES.42: 포인터는 간단하고 직관적인 형태로 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.42: 포인터는 간단하고 직관적인 형태로 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_26" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_20" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_14" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_1" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_21" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_15" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_2" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_16" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_3" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_22" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_32" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_26" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es43" class="md-nav__link">
    ES.43: 평가 순서가 정의되지 않은 표현식은 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.43: 평가 순서가 정의되지 않은 표현식은 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_27" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_23" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_33" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_27" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es44" class="md-nav__link">
    ES.44: 함수 인자가 표현식 평가 순서의 영향을 받지 않게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.44: 함수 인자가 표현식 평가 순서의 영향을 받지 않게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_28" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_24" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_34" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_35" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_28" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es45-magic-constant" class="md-nav__link">
    ES.45: 이유를 알 수 없는 상수(magic constant)를 사용하지 마라; 상징적인 상수를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.45: 이유를 알 수 없는 상수(magic constant)를 사용하지 마라; 상징적인 상수를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_29" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_36" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_29" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es46" class="md-nav__link">
    ES.46: 타입 범위를 축소하는 변환을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.46: 타입 범위를 축소하는 변환을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_30" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_17" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_25" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_30" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es47-0-null-nullptr" class="md-nav__link">
    ES.47: 0 혹은 NULL보다는 nullptr를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.47: 0 혹은 NULL보다는 nullptr를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_31" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_37" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_31" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es48-cast" class="md-nav__link">
    ES.48: 타입 변환(cast)을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.48: 타입 변환(cast)을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_32" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_18" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_26" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_27" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_28" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_8" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternatives" class="md-nav__link">
    Alternatives
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_32" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es49-named-cast" class="md-nav__link">
    ES.49: 타입 변환을 사용해야만 한다면, 미리 정의된 방법으로 변환(named cast)하라
  </a>
  
    <nav class="md-nav" aria-label="ES.49: 타입 변환을 사용해야만 한다면, 미리 정의된 방법으로 변환(named cast)하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_33" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_38" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_29" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_30" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_33" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es50-const" class="md-nav__link">
    ES.50: const를 제거하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.50: const를 제거하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_34" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_19" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_39" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_9" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_40" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_34" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es55" class="md-nav__link">
    ES.55: 범위 검사가 필요없게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.55: 범위 검사가 필요없게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_35" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_41" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_35" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es56-stdmove" class="md-nav__link">
    ES.56: std::move()는 개체를 다른 유효범위로 명시적으로 옮겨야 할때만 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.56: std::move()는 개체를 다른 유효범위로 명시적으로 옮겨야 할때만 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_36" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#notes" class="md-nav__link">
    Notes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_20" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_42" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#notes_1" class="md-nav__link">
    Notes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_21" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_22" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_43" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_36" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es60-new-delete" class="md-nav__link">
    ES.60: 자원을 관리하는 함수 외부에서 new와 delete 사용을 피하라
  </a>
  
    <nav class="md-nav" aria-label="ES.60: 자원을 관리하는 함수 외부에서 new와 delete 사용을 피하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_37" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_31" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_23" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also_1" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_37" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es61-delete-delete" class="md-nav__link">
    ES.61: 배열은 delete[], 단일 개체는 delete를 사용해서 해제하라
  </a>
  
    <nav class="md-nav" aria-label="ES.61: 배열은 delete[], 단일 개체는 delete를 사용해서 해제하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_38" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_24" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_32" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_38" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es62" class="md-nav__link">
    ES.62: 서로 다른 배열에 대한 포인터를 비교하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.62: 서로 다른 배열에 대한 포인터를 비교하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_39" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_25" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_33" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_39" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es63-slice" class="md-nav__link">
    ES.63: 복사 손실(slice)이 없도록 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.63: 복사 손실(slice)이 없도록 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_40" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_44" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_1" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_40" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es64-te" class="md-nav__link">
    ES.64: 개체를 생성할 때는 T{e}표기를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.64: 개체를 생성할 때는 T{e}표기를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_41" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_45" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_34" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_35" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_36" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_10" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_41" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es65-invalid" class="md-nav__link">
    ES.65: 유효하지 않은(invalid) 포인터를 역참조하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.65: 유효하지 않은(invalid) 포인터를 역참조하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_42" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_37" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also_2" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_46" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_47" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_48" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_49" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_42" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esstmt-statement" class="md-nav__link">
    ES.stmt: 구문(statement)
  </a>
  
    <nav class="md-nav" aria-label="ES.stmt: 구문(statement)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es70-if-switch" class="md-nav__link">
    ES.70: 선택을 하는 경우에는 if구문보다는 switch구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.70: 선택을 하는 경우에는 if구문보다는 switch구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_43" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_50" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_43" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es71-for-for-" class="md-nav__link">
    ES.71: 가능하다면 일반 for구문 보다 범위기반 for-구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.71: 가능하다면 일반 for구문 보다 범위기반 for-구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_44" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_51" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_38" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_44" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es72-while-for-" class="md-nav__link">
    ES.72: 루프 변수가 있다면 while-구문보다 for-구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.72: 루프 변수가 있다면 while-구문보다 for-구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_45" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_52" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_26" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_45" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es73-for-while-" class="md-nav__link">
    ES.73: 루프 변수가 없다면 for-구문보다 while-구문을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.73: 루프 변수가 없다면 for-구문보다 while-구문을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_46" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_53" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_46" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es74-for-" class="md-nav__link">
    ES.74: 루프 변수는 for-구문의 초기화 부분에서 선언하라
  </a>
  
    <nav class="md-nav" aria-label="ES.74: 루프 변수는 for-구문의 초기화 부분에서 선언하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_47" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_54" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-dont" class="md-nav__link">
    Example, don't
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#see-also_3" class="md-nav__link">
    See also
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_55" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_47" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#discussion" class="md-nav__link">
    Discussion
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es75-do-" class="md-nav__link">
    ES.75: do-구문을 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.75: do-구문을 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_48" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_56" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_39" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_48" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es76-goto" class="md-nav__link">
    ES.76: goto를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.76: goto를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_49" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_11" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_27" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_49" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es77-break-continue" class="md-nav__link">
    ES.77: break와 continue의 사용을 최소화하라
  </a>
  
    <nav class="md-nav" aria-label="ES.77: break와 continue의 사용을 최소화하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_50" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_57" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_2" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_40" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_50" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es78-case-break" class="md-nav__link">
    ES.78: 내용이 있는 case는 break하라
  </a>
  
    <nav class="md-nav" aria-label="ES.78: 내용이 있는 case는 break하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_51" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_58" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_41" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_51" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es79-default" class="md-nav__link">
    ES.79: (오직) 일반적인 경우를 처리하기 위해서 default를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.79: (오직) 일반적인 경우를 처리하기 위해서 default를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_52" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_59" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_60" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_52" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es84" class="md-nav__link">
    ES.84: 이름이 없는 지역변수는 선언(하려고)하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.84: 이름이 없는 지역변수는 선언(하려고)하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_53" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_28" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_42" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_53" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es85" class="md-nav__link">
    ES.85: 비어있는 구문은 눈에띄게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.85: 비어있는 구문은 눈에띄게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_54" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_61" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_54" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es86-for-body" class="md-nav__link">
    ES.86: for 반복문(body) 안에서 루프 변수를 변경하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.86: for 반복문(body) 안에서 루프 변수를 변경하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_55" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_62" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_55" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es87" class="md-nav__link">
    ES.87: 조건에 불필요한 ==나 !=를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.87: 조건에 불필요한 ==나 !=를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_56" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_63" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_64" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_65" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_43" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_29" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_44" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_56" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arithmetic" class="md-nav__link">
    산술연산(Arithmetic)
  </a>
  
    <nav class="md-nav" aria-label="산술연산(Arithmetic)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es100" class="md-nav__link">
    ES.100: 부호가 있는 타입과 없는 타입을 함께 연산하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.100: 부호가 있는 타입과 없는 타입을 함께 연산하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_57" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_66" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_45" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_57" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es101-unsigned" class="md-nav__link">
    ES.101: 비트 조작시에는 부호가 없는(unsigned) 타입을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.101: 비트 조작시에는 부호가 없는(unsigned) 타입을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_58" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_67" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_46" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_58" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es102-signed" class="md-nav__link">
    ES.102: 연산에는 부호가 있는(signed) 타입을 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.102: 연산에는 부호가 있는(signed) 타입을 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_59" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_68" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_12" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_69" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_59" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es103-overflow" class="md-nav__link">
    ES.103: Overflow가 발생하지 않게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.103: Overflow가 발생하지 않게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_60" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_30" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_31" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_32" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_13" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_3" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_60" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es104-underflow" class="md-nav__link">
    ES.104: Underflow가 발생하지 않게 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.104: Underflow가 발생하지 않게 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_61" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_33" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_14" class="md-nav__link">
    Exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_61" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es105-0" class="md-nav__link">
    ES.105: 0으로 나누지 않도록 하라
  </a>
  
    <nav class="md-nav" aria-label="ES.105: 0으로 나누지 않도록 하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_62" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_47" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_34" class="md-nav__link">
    Example; bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_4" class="md-nav__link">
    Example; good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative_4" class="md-nav__link">
    Alternative
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_62" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es106-unsigned" class="md-nav__link">
    ES.106: 음수값을 막으려고 unsigned를 사용하지 마라
  </a>
  
    <nav class="md-nav" aria-label="ES.106: 음수값을 막으려고 unsigned를 사용하지 마라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_63" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_70" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_71" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternatives_1" class="md-nav__link">
    Alternatives
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_48" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_63" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es107-unsigned-gslindex" class="md-nav__link">
    ES.107: 배열 접근에는 unsigned를 쓰지 말고 gsl::index를 사용하라
  </a>
  
    <nav class="md-nav" aria-label="ES.107: 배열 접근에는 unsigned를 쓰지 말고 gsl::index를 사용하라">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reason_64" class="md-nav__link">
    Reason
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-bad_35" class="md-nav__link">
    Example, bad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-good_5" class="md-nav__link">
    Example, good
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#note_49" class="md-nav__link">
    Note
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_72" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_73" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternatives_2" class="md-nav__link">
    Alternatives
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enforcement_64" class="md-nav__link">
    Enforcement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="http://github.com/CppKorea/CppCoreGuidelines/edit/master/docs/Expr.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <h1 id="es"><a name="S-expr"></a>ES: 표현식과 구문</h1>
<p>표현식(expression)과 구문(statement)은 행위와 연산에 대해 표현하는 가장 직접적인 방법들이다. 지역 유효범위 내에서의 선언 역시 구문에 포함된다.</p>
<p>이름 짓기와 주석, 들여쓰기 규칙에 대해서는, <a href="../Naming/#S-naming">NL: Naming and layout</a>을 참고하라.</p>
<p>일반적인 규칙:</p>
<ul>
<li><a href="#Res-lib">ES.1: 다른 라이브러리나 "직접 짠 코드" 대신 표준 라이브러리를 사용하라</a></li>
<li><a href="#Res-abstr">ES.2: 언어 기능을 바로 사용하기는 보다 적절히 추상화하라</a></li>
</ul>
<p>선언 규칙:</p>
<ul>
<li><a href="#Res-scope">ES.5: 유효범위(scope)는 작게 유지하라</a></li>
<li><a href="#Res-cond">ES.6: for 문의 변수는 유효범위를 제한하기 위해 초기화와 조건 검사부분에서만 선언하라</a></li>
<li><a href="#Res-name-length">ES.7: 일반적이거나 지역범위 변수들의 이름은 짧게, 그렇지 않다면 길게 하라</a></li>
<li><a href="#Res-name-similar">ES.8: 비슷해보이는 이름은 피하라</a></li>
<li><a href="#Res-not-CAPS">ES.9: <code>ALL_CAPS</code> 같은 이름을 피하라</a></li>
<li><a href="#Res-name-one">ES.10: 선언은 (오직) 하나의 이름을 선언해야 한다</a></li>
<li><a href="#Res-auto">ES.11: 타입 이름의 불필요한 반복을 막을때는 <code>auto</code>를 사용하라</a></li>
<li><a href="#Res-reuse">ES.12: 이름을 덮어쓰지 않도록 하라</a></li>
<li><a href="#Res-always">ES.20: 항상 개체를 초기화하라</a></li>
<li><a href="#Res-introduce">ES.21: 사용할 필요가 없을 때 변수나 상수를 선언하지 마라</a></li>
<li><a href="#Res-init">ES.22: 변수를 초기화할 값이 생길 때까지 선언하지 마라</a></li>
<li><a href="#Res-list">ES.23: <code>{}</code> 초기화 문법을 사용하라</a></li>
<li><a href="#Res-unique">ES.24: 포인터는 <code>unique_ptr&lt;T&gt;</code>에 담아라</a></li>
<li><a href="#Res-const">ES.25: 값을 변경하지 않는다면 개체를 <code>const</code> 혹은 <code>constexpr</code>로 선언하라</a></li>
<li><a href="#Res-recycle">ES.26: 서로 상관없는 목적에 하나의 변수를 사용하지 마라</a></li>
<li><a href="#Res-stack">ES.27: 스택에서 사용되는 배열은 <code>std::array</code>나 <code>stack_array</code>를 사용하라</a></li>
<li><a href="#Res-lambda-init">ES.28: 복잡한 초기화, 특히 <code>const</code> 변수의 초기화에는 람다를 사용하라</a></li>
<li><a href="#Res-macros">ES.30: 프로그램 텍스트를 다루기(manipulate) 위해 매크로를 사용하지 마라</a></li>
<li><a href="#Res-macros2">ES.31: 매크로를 상수나 "함수"에 사용하지 마라</a></li>
<li><a href="#Res-ALL_CAPS">ES.32: 모든 매크로는 <code>ALL_CAPS</code> 형태로 선언하라</a></li>
<li><a href="#Res-MACROS">ES.33: 매크로를 사용해야만 한다면, 고유한 이름을 사용하라</a></li>
<li><a href="#Res-ellipses">ES.34: (C-스타일의) 가변인자 함수를 정의하지 마라</a></li>
</ul>
<p>표현식 규칙:</p>
<ul>
<li><a href="#Res-complicated">ES.40: 복잡한 표현식을 피하라</a></li>
<li><a href="#Res-parens">ES.41: 연산자 우선순위가 불분명하면, 소괄호를 사용하라(parenthesize)</a></li>
<li><a href="#Res-ptr">ES.42: 포인터는 간단하고 직관적인 형태로 사용하라</a></li>
<li><a href="#Res-order">ES.43: 평가 순서가 정의되지 않은 표현식은 사용하지 마라</a></li>
<li><a href="#Res-order-fct">ES.44: 함수 인자가 표현식 평가 순서의 영향을 받지 않게 하라</a></li>
<li><a href="#Res-magic">ES.45: 이유를 알 수 없는 상수(magic constant)를 사용하지 마라; 상징적인 상수를 사용하라</a></li>
<li><a href="#Res-narrowing">ES.46: 타입 범위를 축소하는 변환을 피하라</a></li>
<li><a href="#Res-nullptr">ES.47: <code>0</code> 혹은 <code>NULL</code>보다는 <code>nullptr</code>를 사용하라</a></li>
<li><a href="#Res-casts">ES.48: 타입 변환(cast)을 피하라</a></li>
<li><a href="#Res-casts-named">ES.49: 타입 변환을 사용해야만 한다면, 미리 정의된 방법으로 변환(named cast)하라</a></li>
<li><a href="#Res-casts-const">ES.50: <code>const</code>를 제거하지 마라</a></li>
<li><a href="#Res-range-checking">ES.55: 범위 검사가 필요없게 하라</a></li>
<li><a href="#Res-move">ES.56: <code>std::move()</code>는 개체를 다른 유효범위로 명시적으로 옮겨야 할때만 사용하라</a></li>
<li><a href="#Res-new">ES.60: 자원을 관리하는 함수 외부에서 <code>new</code>와 <code>delete</code> 사용을 피하라</a></li>
<li><a href="#Res-del">ES.61: 배열은 <code>delete[]</code>, 단일 개체는 <code>delete</code>를 사용해서 해제하라</a></li>
<li><a href="#Res-arr2">ES.62: 서로 다른 배열에 대한 포인터를 비교하지 마라</a></li>
<li><a href="#Res-slice">ES.63: 복사 손실(slice)이 없도록 하라</a></li>
<li><a href="#Res-construct">ES.64: 개체를 생성할 때는 <code>T{e}</code>표기를 사용하라</a></li>
<li><a href="#Res-deref">ES.65: 유효하지 않은(invalid) 포인터를 역참조하지 마라</a></li>
</ul>
<p>구문 규칙:</p>
<ul>
<li><a href="#Res-switch-if">ES.70: 선택을 하는 경우에는 <code>if</code>구문보다는 <code>switch</code>구문을 사용하라</a></li>
<li><a href="#Res-for-range">ES.71: 가능하다면 일반 <code>for</code>구문 보다 범위기반 <code>for</code>-구문을 사용하라</a></li>
<li><a href="#Res-for-while">ES.72: 루프 변수가 있다면 <code>while</code>-구문보다 <code>for</code>-구문을 사용하라</a></li>
<li><a href="#Res-while-for">ES.73: 루프 변수가 없다면 <code>for</code>-구문보다 <code>while</code>-구문을 사용하라</a></li>
<li><a href="#Res-for-init">ES.74: 루프 변수는 <code>for</code>-구문의 초기화 부분에서 선언하라</a></li>
<li><a href="#Res-do">ES.75: <code>do</code>-구문을 사용하지 마라</a></li>
<li><a href="#Res-goto">ES.76: <code>goto</code>를 사용하지 마라</a></li>
<li><a href="#Res-continue">ES.77: <code>break</code>와 <code>continue</code>의 사용을 최소화하라</a></li>
<li><a href="#Res-break">ES.78: 내용이 있는 <code>case</code>는 <code>break</code>하라</a></li>
<li><a href="#Res-default">ES.79: (오직) 일반적인 경우를 처리하기 위해서 <code>default</code>를 사용하라</a></li>
<li><a href="#Res-noname">ES.84: 이름이 없는 지역변수는 선언(하려고)하지 마라</a></li>
<li><a href="#Res-empty">ES.85: 비어있는 구문은 눈에띄게 하라</a></li>
<li><a href="#Res-loop-counter">ES.86: for 반복문(body) 안에서 루프 변수를 변경하지 마라</a></li>
<li><a href="#Res-if">ES.87: 조건에 불필요한 <code>==</code>나 <code>!=</code>를 사용하지 마라</a></li>
</ul>
<p>산술연산 규칙:</p>
<ul>
<li><a href="#Res-mix">ES.100: 부호가 있는 타입과 없는 타입을 함께 연산하지 마라</a></li>
<li><a href="#Res-unsigned">ES.101: 비트 조작시에는 부호가 없는(unsigned) 타입을 사용하라</a></li>
<li><a href="#Res-signed">ES.102: 연산에는 부호가 있는(signed) 타입을 사용하라</a></li>
<li><a href="#Res-overflow">ES.103: Overflow가 발생하지 않게 하라</a></li>
<li><a href="#Res-underflow">ES.104: Underflow가 발생하지 않게 하라</a></li>
<li><a href="#Res-zero">ES.105: 0으로 나누지 않도록 하라</a></li>
<li><a href="#Res-nonnegative">ES.106: 음수값을 막으려고 <code>unsigned</code>를 사용하지 마라</a></li>
<li><a href="#Res-subscripts">ES.107: 배열 접근에는 <code>unsigned</code>를 쓰지 말고 <code>gsl::index</code>를 사용하라</a></li>
</ul>
<h3 id="es1"><a name="Res-lib"></a>ES.1: 다른 라이브러리나 "직접 짠 코드" 대신 표준 라이브러리를 사용하라</h3>
<h5 id="reason">Reason</h5>
<p>라이브러리를 사용하는 코드는 언어의 기능을 직접적으로 사용하는 것보다 쉽고, 더 짧게 작성할 수 있고, 고수준의 추상화가 가능하다.
ISO C++ 표준 라이브러리는 널리 알려져있으며 테스트가 잘된 라이브러리다.
모든 C++ 구현체에서 제공하고 있다.</p>
<h5 id="example">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>   <span class="c1">// good</span>
</code></pre></div>


<p><code>accumulate</code>의 Ranges 버전이 더 낫다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// better</span>
</code></pre></div>


<p>잘 알려진 알고리즘을 직접 만들 필요는 없다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>   <span class="c1">// bad: verbose, 목적이 적혀있지 않다</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</code></pre></div>


<h5 id="exception">Exception</h5>
<p>표준 라이브러리의 대다수가 동적 할당(자유 저장소)에 의존한다.
이런 부분은 알고리즘의 문제는 아닐지라도, 제한 시간 내에 응답성을 보장해야 하는 경우(hard real-time)나 임베디드 환경에는 적합하지 않다.
그런 경우는 비슷한 기능을 구현하여 사용하는 것을 고려해볼 수 있다. 예를 들면 표준 라이브러리 스타일로 구현된 메모리 풀 할당 컨테이너 같은 것들이다.</p>
<h5 id="enforcement">Enforcement</h5>
<p>쉽지 않다.<br />
??? 지저분한 반복문, 중첩 반복문, 긴 함수, 함수 호출의 부재, 내장 타입이 아닌 타입을 거의 사용하지 않는 경우. 순환 복잡성?</p>
<h3 id="es2"><a name="Res-abstr"></a>ES.2: 언어 기능을 바로 사용하기는 보다 적절히 추상화하라</h3>
<h5 id="reason_1">Reason</h5>
<p>"적절한 추상화"(예를 들어 라이브러리나 클래스 같은 것)가 언어보다 어플리케이션의 개념에 더 가깝다. 
코드를 짧고 명확하게 만들 수 있으며, 테스트하기에도 더 쉽다.</p>
<h5 id="example_1">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read1</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">)</span>   <span class="c1">// good</span>
    <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;)</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>아래와 같은 전통적인 코드, 시스템 레벨과 거의 동등한 저수준(low-level) 코드는 길고, 지저분하고, 이해하기도 어렵고, 느리게 돌아간다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">char</span><span class="o">**</span> <span class="nf">read2</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxelem</span><span class="p">,</span> 
                 <span class="kt">int</span> <span class="n">maxstring</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">nread</span><span class="p">)</span> <span class="c1">// bad: verbose and incomplete</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">*</span><span class="p">[</span><span class="n">maxelem</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">elemcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;&amp;</span> <span class="n">elemcount</span> <span class="o">&lt;</span> <span class="n">maxelem</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">maxstring</span><span class="p">];</span>
            <span class="n">is</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">maxstring</span><span class="p">);</span>
            <span class="n">res</span><span class="p">[</span><span class="n">elemcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">nread</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elemcount</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>오버플로우나 오류처리 코드가 한 번 들어가게 되면, 코드는 급격히 지저분해진다. 
그리고, 반환하는 포인터와 배열로 구현되는 C 스타일의 문자열을 <code>delete</code>를 꼭 해줘야하는 문제도 있다.</p>
<h5 id="enforcement_1">Enforcement</h5>
<p>쉽지 않다.<br />
??? 지저분한 반복문, 중첩 반복문, 긴 함수, 함수 호출의 부재, 내장 타입이 아닌 타입을 거의 사용하지 않는 경우. 순환 복잡성?</p>
<h2 id="esdcl-declarations">ES.dcl: 선언(Declarations)</h2>
<p>선언은 구문(statement)이다. 한 선언은 임의의 유효 범위에 하나의 이름을 만들거나 이름있는 개체(named object)를 생성할 수 있다.</p>
<h3 id="es5-scope"><a name="Res-scope"></a>ES.5: 유효범위(scope)는 작게 유지하라</h3>
<h5 id="reason_2">Reason</h5>
<p>가독성이 좋아진다. 리소스 점유를 최소화할 수 있다. 값의 잘못된 사용을 피할 수 있다.</p>
<p><strong>Alternative Formulation</strong>:<br />
불필요하게 큰 스코프에 변수를 선언하지 마라</p>
<h5 id="example_2">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// bad: i 가 반복문 이후에도 불필요하게 접근 가능하다</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
            <span class="cm">/* ... */</span> 
        <span class="p">}</span>

        <span class="c1">// 위에서 선언한 i를 사용하지 않는다</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// good: i 는 for 반복문의 범위에서만 존재한다</span>
            <span class="cm">/* ... */</span>
        <span class="p">}</span>

        <span class="c1">// good: pc 는 if 문의 범위에서만 존재한다</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pc</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span> <span class="p">{</span> 
            <span class="c1">// ... deal with Circle ...</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ... handle error ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-bad">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;.txt&quot;</span><span class="p">;</span>
        <span class="n">ifstream</span> <span class="n">is</span> <span class="p">{</span><span class="n">fn</span><span class="p">};</span>
        <span class="n">Record</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
        <span class="c1">// ... 여기에는 fn과 is를 쓰면 안되는 200 줄짜리 코드가 들어간다 ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>이 코드는 길다는 문제점이 있지만, <code>fn</code>의 값과 <code>is</code>가 갖고 있는 파일 핸들이 필요 이상으로 훨씬 길게 유지된다는 게 문제다.
이러면 함수의 뒷부분에서 <code>is</code>와 <code>fn</code>을 실수로 사용해버릴 수 있다.</p>
<p>이럴 때는, 분할해버리는 게 낫다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">Record</span> <span class="nf">load_record</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;.txt&quot;</span><span class="p">;</span>
        <span class="n">ifstream</span> <span class="n">is</span> <span class="p">{</span><span class="n">fn</span><span class="p">};</span>
        <span class="n">Record</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Record</span> <span class="n">r</span> <span class="o">=</span> <span class="n">load_record</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="c1">// ... 200 줄 코드 ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_2">Enforcement</h5>
<ul>
<li>루프 바깥에서 루프 변수가 선언되고 이후에는 사용되지 않는 경우를 지적한다</li>
<li>파일 핸들이나 잠금과 같은 중요한 리소스를 사용하는 코드가 (적당히 큰) N줄 이상 계속되면 지적한다</li>
</ul>
<h3 id="es6-for"><a name="Res-cond"></a>ES.6: for 문의 변수는 유효범위를 제한하기 위해 초기화와 조건 검사부분에서만 선언하라</h3>
<h5 id="reason_3">Reason</h5>
<p>가독성. 시스템 자원 점유를 최소화한다.</p>
<h5 id="example_3">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;)</span>
            <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

        <span class="c1">// good: i 는 for 반복문의 범위에서만 존재한다</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>

        <span class="c1">// good: pc 는 if 문의 범위에서만 존재한다</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pc</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// ... deal with Circle ...</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ... handle error ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_3">Enforcement</h5>
<ul>
<li>루프 바깥에서 루프 변수가 선언되고 이후에는 사용되지 않을 때 지적하라</li>
<li>(어려움) 루프 바깥에서 루프 변수를 선언하고, 루프가 끝난 뒤에 관계없는 목적으로 그 변수를 사용하는 경우 지적하라</li>
</ul>
<h5 id="c17-example">C++17 example</h5>
<p>C++17 에서는 <code>if</code>와 <code>switch</code>에 초기화 구문이 추가되었다. C++ 17을 지원하는 경우는 아래처럼 작성할 수 있다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">mymap</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// insert가 성공했고, 반환된 결과는 이 블록에서만 유효하다(valid)</span>
        <span class="n">use</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>  <span class="c1">// ok</span>
        <span class="c1">// ...</span>
    <span class="p">}</span> <span class="c1">// result 는 이 시점에 파괴된다</span>
</code></pre></div>


<h5 id="c17-enforcement-if-using-a-c17-compiler">C++17 enforcement (if using a C++17 compiler)</h5>
<ul>
<li>선택/반복 구문의 변수가 미리 선언되고 구문 이후에는 사용되지 않으면 지적하라</li>
<li>(어려움) 선택/반복 구문의 변수가 미리 선언되고 구문 이후에 다른 상관없는 목적으로 사용되면 지적하라</li>
</ul>
<h3 id="es7"><a name="Res-name-length"></a>ES.7: 일반적이거나 지역범위 변수들의 이름은 짧게, 그렇지 않다면 길게 하라</h3>
<h5 id="reason_4">Reason</h5>
<p>가독성. 관계없는 비-지역(non-local) 변수 간의 충돌 확률을 낮춘다.</p>
<h5 id="example_4">Example</h5>
<p>관습적으로 쓰이는 짧은 지역변수명은 가독성을 향상시킨다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>    <span class="c1">// good</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>인덱스는 관습적으로 <code>i</code>를 사용하고, 이 일반 함수에는 벡터의 의미를 알만한 힌트가 없으므로, <code>v</code>가 어떤 경우에든지 맞는 이름이다.</p>
<p>비교:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Element_type</span><span class="o">&gt;</span>   <span class="c1">// bad: 읽기 어렵다</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">target_stream</span><span class="p">,</span> 
               <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Element_type</span><span class="o">&gt;&amp;</span> <span class="n">current_vector</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">current_element_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
             <span class="n">current_element_index</span> <span class="o">&lt;</span> <span class="n">current_vector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
             <span class="o">++</span><span class="n">current_element_index</span>
        <span class="p">)</span>
        <span class="n">target_stream</span> <span class="o">&lt;&lt;</span> <span class="n">current_vector</span><span class="p">[</span><span class="n">current_element_index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>과장해서 표현하긴 했지만, 이것보다 더 심한 것도 본적이 있다.</p>
<h5 id="example_5">Example</h5>
<p>관습에 따르지 않는 짧은 비지역 변수는 코드를 모호하게 만든다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use1</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">tt</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>   <span class="c1">// bad: what is tt()?</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>비지역 개체들에는 좀 더 가독성 있는 이름을 쓰면 나아진다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use1</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">trim_tail</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>   <span class="c1">// better</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>이렇게 하면, 코드를 읽는 사람이 <code>trim_tail</code>의 의미를 알 수 있게 되고, 기억할 수 있게 된다.</p>
<h5 id="example-bad_1">Example, bad</h5>
<p>내용이 긴 함수의 인자는 사실상 비지역 변수라고 볼 수 있다. 따라서 인자들의 이름은 적절한 의미를 담아야 한다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">complicated_algorithm</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Record</span><span class="o">&gt;&amp;</span> <span class="n">vr</span><span class="p">,</span> 
                               <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vi</span><span class="p">,</span>
                               <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">out</span><span class="p">)</span>
        <span class="c1">// vi의 인덱스들을 사용해서</span>
        <span class="c1">// vr에서 이벤트를 읽고 (Records)</span>
        <span class="c1">// out에 (name, index) 쌍을 넣는다</span>
    <span class="p">{</span>
        <span class="c1">// ... 500 lines of code using vr, vi, and out ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>함수는 짧게 유지하는 것을 권장하지만, 이 규칙을 모두 적용시키긴 힘들 때가 있다.
그럴 경우엔 변수에 이름을 적절히 부여해야 한다.</p>
<h5 id="enforcement_4">Enforcement</h5>
<p>지역 변수와 비지역 변수의 이름이 유지되는 범위의 길이를 확인한다. 동시에 함수의 길이를 함께 고려한다.</p>
<h3 id="es8"><a name="Res-name-similar"></a>ES.8: 비슷해보이는 이름은 피하라</h3>
<h5 id="reason_5">Reason</h5>
<p>코드의 명확함과 가독성.
너무 비슷한 이름은 이해를 저해하고 오류가 발생할 소지를 낳는다.</p>
<h5 id="example-bad_2">Example; bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">readable</span><span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">ol</span> <span class="o">+</span> <span class="n">o1</span> <span class="o">+</span> <span class="n">o0</span> <span class="o">+</span> <span class="n">ol</span> <span class="o">+</span> <span class="n">o1</span> <span class="o">+</span> <span class="n">I0</span> <span class="o">+</span> <span class="n">l0</span><span class="p">))</span>
        <span class="n">surprise</span><span class="p">();</span>
</code></pre></div>


<h5 id="example-bad_3">Example; bad</h5>
<p>같은 유효범위에서 타입이 아닌 것을 타입의 이름과 같은 이름으로 선언하지마라.
이러면 <code>struct</code> 혹은 <code>enum</code>을 사용해서 이름의 의미을 구분할 필요가 없게 된다.</p>
<p><code>struct X</code> 같은 코드는 이름 탐색(lookup)이 실패하면 암묵적으로 <code>X</code>로 간주되기 때문에 오류의 원인을 제거하는 효과도 얻을 수 있다. </p>
<div class="codehilite"><pre><span></span><code>    <span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="p">};</span>

    <span class="k">struct</span> <span class="n">foo</span> <span class="nf">foo</span><span class="p">();</span>       <span class="c1">// BAD, foo는 이미 타입의 이름으로 쓰이고 있다</span>
    <span class="k">struct</span> <span class="n">foo</span> <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>   <span class="c1">// 설명이 필요하다</span>
</code></pre></div>


<h5 id="exception_1">Exception</h5>
<p>좀 오래된(antique) 헤더 파일들은 타입이 아닌 것에 타입과 같은 이름을 붙여놓았을 수도 있다.</p>
<h5 id="enforcement_5">Enforcement</h5>
<ul>
<li>이미 알려진 (혼란을 일으키는) 글자 혹은 숫자 조합을 사용하는 이름이 있는지 검사한다</li>
<li>변수, 함수, 열거자(enumerator)의 선언이 같은 유효범위에서 선언된 클래스 혹은 열거형을 가리는(hide) 경우 지적한다</li>
</ul>
<h3 id="es9-all_caps"><a name="Res-not-CAPS"></a>ES.9: <code>ALL_CAPS</code> 같은 이름을 피하라</h3>
<h5 id="reason_6">Reason</h5>
<p>이런 이름은 보통 매크로를 정의할 때 사용한다. 따라서 <code>ALL_CAPS</code> 형태의 이름은 매크로와 충돌될 가능성이 많다. </p>
<h5 id="example_6">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// 어떤 헤더파일의 어느 지점:</span>
    <span class="cp">#define NE !=</span>

    <span class="c1">// 다른 어떤 헤더파일의 어느 지점:</span>
    <span class="k">enum</span> <span class="n">Coord</span> <span class="p">{</span> <span class="n">N</span><span class="p">,</span> <span class="n">NE</span><span class="p">,</span> <span class="n">NW</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">SE</span><span class="p">,</span> <span class="n">SW</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">W</span> <span class="p">};</span>

    <span class="c1">// 어느 불쌍한 프로그래머의 .cpp 파일 어느 지점:</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">N</span><span class="p">:</span>
        <span class="c1">// ...</span>
    <span class="k">case</span> <span class="nl">NE</span><span class="p">:</span>
        <span class="c1">// ...</span>
    <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note">Note</h5>
<p>단지 상수가 매크로처럼 쓰인다는 이유로 상수에 <code>ALL_CAPS</code> 형태의 이름을 사용하면 안된다</p>
<h5 id="enforcement_6">Enforcement</h5>
<p>대문자만을 사용한 이름을 지적하라. 오래된 코드에 대해서는 매크로 이름으로 소문자를 섞어 사용한 경우를 지적하라</p>
<h3 id="es10"><a name="Res-name-one"></a>ES.10: 선언은 (오직) 하나의 이름을 선언해야 한다</h3>
<h5 id="reason_7">Reason</h5>
<p>한 줄에 선언 하나씩 하면 가독성을 향상시킬 수 있고, C/C++ 문법과 관련된 실수를 피할 수 있다. 
그리고 <code>//</code> 주석을 달 수 있는 공간이 생긴다.</p>
<h5 id="example-bad_4">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="o">**</span><span class="n">aa</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>   <span class="c1">// 윽 이게뭐야!</span>
</code></pre></div>


<h5 id="exception_2">Exception</h5>
<p>함수 선언은 다수의 함수 인자 선언을 포함할 수 있다.</p>
<h5 id="exception_3">Exception</h5>
<p>C++ 17 의 structured binding은 여러 변수를 동시에 선언하기 위해 설계되었다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="p">[</span><span class="n">iter</span><span class="p">,</span> <span class="n">inserted</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">insert_or_assign</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inserted</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* new entry was inserted */</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example_7">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">any_of</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span>
</code></pre></div>


<p>컨셉(concepts)를 사용하면 이렇게 된다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">bool</span> <span class="nf">any_of</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span>
</code></pre></div>


<h5 id="example_8">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="nf">scalbn</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>   <span class="c1">// OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2</span>
</code></pre></div>


<p>또는:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="nf">scalbn</span><span class="p">(</span>    <span class="o">//</span> <span class="nl">better</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">FLT_RADIX</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="n">FLT_RADIX</span> <span class="n">is</span> <span class="n">usually</span> <span class="mi">2</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span>     <span class="c1">// base value</span>
        <span class="kt">int</span> <span class="n">n</span>         <span class="c1">// exponent</span>
    <span class="p">);</span>
</code></pre></div>


<p>또는:</p>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2</span>
    <span class="kt">double</span> <span class="nf">scalbn</span><span class="p">(</span><span class="kt">double</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exponent</span><span class="p">);</span>
</code></pre></div>


<h5 id="example_9">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div>


<p>여러 변수들을 한번에 선언하는 것은 초기화되지 않은 변수를 간과하기 쉽다.</p>
<h5 id="enforcement_7">Enforcement</h5>
<p>변수와 상수들을 한번에 선언을 한 곳을 지적한다.(예를 들어, <code>int* p, q;</code>)</p>
<h3 id="es11-auto"><a name="Res-auto"></a>ES.11: 타입 이름의 불필요한 반복을 막을때는 <code>auto</code>를 사용하라</h3>
<h5 id="reason_8">Reason</h5>
<ul>
<li>간단한 내용이 반복되면 지루하고 오류에 취약하다.</li>
<li><code>auto</code>를 사용하면 선언된 개체(entity)가 그 지점에 고정되고, 가독성을 향상시킨다.</li>
<li>템플릿 함수 선언에서는 반환 타입이 멤버 타입일 수 있다.</li>
</ul>
<h5 id="example_10">Example</h5>
<p>이런 코드를 생각해보자:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>   <span class="c1">// vector&lt;int&gt;::iterator</span>
    <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">future</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>


<p>각각의 경우, 타입들을 컴파일러가 이미 알고 있지만, 프로그래머가 기억하기 힘든 긴 이름의 타입을 작성할 필요가 없게 된다.</p>
<h5 id="example_11">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">first</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">;</span>   <span class="c1">// Container&lt;T&gt;::Iterator</span>
</code></pre></div>


<h5 id="exception_4">Exception</h5>
<p>초기화 리스트(initializer list), 그리고 초기화가 당신이 의도한(그리고 정확히 알고있는) 타입으로 변환되어야 하는 경우에는 <code>auto</code>의 사용을 피하라.</p>
<h5 id="example_12">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">lst</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>   <span class="c1">// lst는 initializer_list&lt;int&gt; 타입이다</span>

    <span class="k">auto</span> <span class="n">x</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>  <span class="c1">// C++ 17에서 x는 int 타입이지만,</span>
                <span class="c1">// C++ 11에서는 initializer_list로 처리된다</span>
</code></pre></div>


<h5 id="note_1">Note</h5>
<p>컨셉(concepts)을 사용할 수 있게되면, 추론되는 타입을 좀 더 분명하게 표기할 수 있다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// ...</span>
    <span class="n">ForwardIterator</span> <span class="n">p</span> <span class="o">=</span> <span class="n">algo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</code></pre></div>


<h5 id="example-c17">Example (C++17)</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="p">[</span> <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="p">]</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="mi">123456</span><span class="p">,</span> <span class="mi">73</span><span class="p">);</span>   <span class="c1">// 반환되는 div_t 타입의 멤버들을 분리해서 선언하게 된다</span>
</code></pre></div>


<h5 id="enforcement_8">Enforcement</h5>
<p>선언에서 장황한(redundant) 타입 이름이 반복되면 지적한다</p>
<h3 id="es12"><a name="Res-reuse"></a>ES.12: 이름을 덮어쓰지 않도록 하라</h3>
<h5 id="reason_9">Reason</h5>
<p>어떤 변수가 사용되고 있는지 혼동하기 쉽다.
유지보수에 문제가 될수도 있다.</p>
<h5 id="example-bad_5">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">value_to_be_returned</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
</code></pre></div>


<p>예시가 아주 큰 <code>if</code> 구문이었다면, 구문 안에서 새로운 <code>d</code>가 선언되는 것을 보지 못했을 수도 있다.
이런 코드는 버그의 원인으로 알려져있다.</p>
<p>보통 이렇게 더 깊은 유효범위에서 같은 이름을 사용하는 것을 "shadowing"이라고도 한다.</p>
<h5 id="note_2">Note</h5>
<p>Shadowing은 함수가 너무 크거나 복잡할때 문제가 된다.</p>
<h5 id="example_13">Example</h5>
<p>가장 바깥 범위에서 함수 인자들을 가리는 것은 언어에서 금지하고 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="c1">// error: reuse of function argument name</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>  <span class="c1">// allowed, but bad</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-bad_6">Example, bad</h5>
<p>멤버의 이름을 지역 변수로 사용하는 것 또한 문제가 된다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="n">S</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>    <span class="c1">// 멤버 변수에 대입한다</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
            <span class="c1">// ...</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span> <span class="c1">// 멤버 변수에 대입한다</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="exception_5">Exception</h5>
<p>상위 클래스의 함수 이름을 하위 클래스에서 재사용하기도 한다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
        <span class="k">using</span> <span class="n">B</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>이는 오류에 취약하다.
예를 들어, using 선언을 하지 않았다면, <code>d.f(1)</code>의 호출은 <code>f(int)</code>를 찾지 못할 것이다.</p>
<p>??? 클래스 계층구조에서 shadowing/hiding에 대한 규칙이 필요할까요?</p>
<h5 id="enforcement_9">Enforcement</h5>
<ul>
<li>더 깊은(nested) 지역범위에서 이름을 재사용하면 지적하라</li>
<li>멤버 함수에서 멤버 이름을 지역변수의 이름으로 사용하면 지적하라</li>
<li>전역범위의 이름을 지역 변수 혹은 멤버의 이름으로 사용하면 지적하라</li>
<li>상위 클래스 멤버의 이름을 하위 클래스에서 재사용하면 지적하라 (함수 이름은 제외)</li>
</ul>
<h3 id="es20"><a name="Res-always"></a>ES.20: 항상 개체를 초기화하라</h3>
<h5 id="reason_10">Reason</h5>
<p>값을 저장하기 전에 사용하는 오류와 관련된 미정의 행동(undefined behavior)를 방지한다.
복잡한 초기화를 이해하면서 생기는 문제를 예방한다.
리팩토링이 쉬워진다.</p>
<h5 id="example_14">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">// bad: 초기화가 안된 변수</span>
        <span class="c1">// ...</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// i를 초기화한다</span>
    <span class="p">}</span>
</code></pre></div>


<p>이런 코드는 좋지 않다. <code>i = 7</code>는 <code>i</code>를 초기화하는 것이 아니다; 변수에 값을 대입을 하는 것이다.
또한, <code>i</code>는 <code>...</code>부분에서 값을 읽을 수 있다. 이렇게 작성하는 것이 더 좋다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>   <span class="c1">// OK</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// OK: 초기화한다</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>    <span class="c1">// OK: 기본값으로 초기화한다</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_3">Note</h5>
<p><em>언제나 초기화하라</em>는 규칙은 <em>개체는 사용되기 전에 값을 가져야 한다</em>는 언어 규칙보다 (의도적으로) 엄격하다.
후자는 더 완화된 규칙으로, 기술적인 버그를 잡을수는 있다, 하지만:</p>
<ul>
<li>가독성이 더 낮다</li>
<li>필요한 범위 이상으로 이름을 선언하도록 만든다</li>
<li>복잡한 코드로 인한 논리적 버그를 발생시킨다</li>
<li>리팩토링을 방해한다</li>
</ul>
<p><em>언제나 초기화하라</em>는 규칙은 값을 저장하지 않고 사용하는 오류를 막는 것 이외에도 유지보수성을 높이는데 초점을 둔 규칙이다.</p>
<h5 id="example_15">Example</h5>
<p>초기화에 대한 좀 더 약한 규칙이 필요한 경우를 보여주는 예시가 있다</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">widget</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">// &quot;widget&quot; 이 초기화에 비용이 많이 드는 타입이라고 하자 </span>
                <span class="c1">// 굉장히 큰 POD 일수도 있다</span>
    <span class="n">widget</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bad: i와 j가 &quot;뒤늦게&quot; 초기화된다</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">f1</span><span class="p">();</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">f2</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">f3</span><span class="p">();</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">f4</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div>


<p>이런 코드는 <code>i</code>와 <code>j</code>를 초기화 하는 형태로 다시 작성하기 어렵다.
기본 생성자를 가지는 타입들에 대해서는, 초기화를 지연하는 코드는 기본 초기화를 하고 대입이 따라오는 구조가 된다.
이런 예시처럼 작성되는 이유는 보통 "효율적이기" 때문이다. 하지만 컴파일러가 값을 설정하지 않고 사용하는 오류를 찾을 수 있다면 초기화의 중복을 제거할수도 있다.</p>
<p><code>i</code>와 <code>j</code>에 논리적인 상관관계가 있다고 가정하자. 이런 연결은 코드에 나타났을 것이다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">pair</span><span class="o">&lt;</span><span class="n">widget</span><span class="p">,</span> <span class="n">widget</span><span class="o">&gt;</span> <span class="n">make_related_widgets</span><span class="p">(</span><span class="kt">bool</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">?</span> <span class="p">{</span><span class="n">f1</span><span class="p">(),</span> <span class="n">f2</span><span class="p">()}</span> <span class="o">:</span> <span class="p">{</span><span class="n">f3</span><span class="p">(),</span> <span class="n">f4</span><span class="p">()};</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_related_widgets</span><span class="p">(</span><span class="n">cond</span><span class="p">);</span>    <span class="c1">// C++17</span>
</code></pre></div>


<h5 id="note_4">Note</h5>
<p>복잡한 초기화는 수십년간 똑똑한 프로그래머들이 자주 사용해왔다.
동시에 복잡성과 오류의 주 원인이기도 했다.
이런 오류들은 초기 구현 이후 유지보수 단게에서 많이 발견되었다.</p>
<h5 id="example_16">Example</h5>
<p>이 규칙은 멤버 변수에도 적용된다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ci</span><span class="p">)</span> <span class="o">:</span> <span class="n">m2</span><span class="p">{</span><span class="n">i</span><span class="p">},</span> <span class="n">cm2</span><span class="p">{</span><span class="n">ci</span><span class="p">}</span> <span class="p">{}</span>
        <span class="c1">// ...</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">m1</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m3</span><span class="p">;</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">cm1</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">cm2</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">cm3</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>컴파일러가 <code>cm3</code>가 <code>const</code>인데도 초기화되지 않은 것을 지적할 것이다. 하지만 이는 <code>m3</code>이 초기화되지 않은 것을 잡아내지는 않는다.</p>
<p>보통, 가짜(spurious) 멤버 초기화는 초기화 하지 않음으로써 오류를 만들지 않기에 그만한 가치가 있다.
또 경우에 따라 최적화기에서 불필요한(redundant) 초기화를 제거할수도 있다.
(예컨대, 대입 직전에 초기화를 수행하는 경우)</p>
<h5 id="exception_6">Exception</h5>
<p>입력에 따라 초기화되는 개체를 선언하고 있다면, 그 개체를 초기화 하는 것은 초기화를 2번 수행하는 것이다.
하지만, 이런 방법은 입력 이후에 초기화하지 않은 부분을 남길수도 있다는 점에 유의하라 -- 이는 보안과 관련된 오류의 온상(fertile source)이 되어왔다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">buf</span><span class="p">[</span><span class="n">max</span><span class="p">];</span>       <span class="c1">// OK, but suspicious: uninitialized</span>
    <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>상황에 따라 배열을 초기화하는 비용이 막대할수도 있다.
하지만, 그런 경우는 초기화되지 않은 부분에 접근할 수 있도록 의도한 것이며, 초기화되지 않았다는 사실을 고려하면서 사용한다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">buf</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>  <span class="c1">// 모든 원소들을 0으로 초기화한다</span>
                        <span class="c1">// 어떤 상황에서는 더 나은 방법이 된다</span>
    <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>할 수 있다면 오버플로우가 발생하지 않는 라이브러리 함수를 사용하라. 예를 들어:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>   <span class="c1">// s는 기본값 &quot;&quot;로 초기화된다</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>   <span class="c1">// s가 입력 문자열을 담기 위해 확장된다</span>
</code></pre></div>


<p>입력 처리의 대상이 되는 변수들도 예외는 아니다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">// bad</span>
    <span class="c1">// ...</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
</code></pre></div>


<p>보통 입력의 대상과 입력 처리가 분리되는 경우 (그러면 안되지만) used-before-set의 가능성이 발생한다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 좀 더 나은 코드, 0이 i2에 허용되는 값이라고 가정한다</span>
    <span class="c1">// ...</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i2</span><span class="p">;</span>
</code></pre></div>


<p>좋은 최적화기는 입력 처리(operation)에 대해 알고있어야 하며, 중복되는 부분을 제거해야 한다</p>
<h5 id="example_17">Example</h5>
<p>"초기화되지 않은" 상태를 보여주는 값을 사용하는 것은 해결방법이 아니며 문제가 있는 것이다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">widget</span> <span class="n">i</span> <span class="o">=</span> <span class="n">uninit</span><span class="p">;</span>  <span class="c1">// bad</span>
    <span class="n">widget</span> <span class="n">j</span> <span class="o">=</span> <span class="n">uninit</span><span class="p">;</span>

    <span class="c1">// ...</span>
    <span class="n">use</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>         <span class="c1">// possibly used before set</span>
    <span class="c1">// ...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">// bad: i and j are initialized &quot;late&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">f1</span><span class="p">();</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">f2</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">f3</span><span class="p">();</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">f4</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div>


<p>이 코드는 이제 컴파일러가 used-before-set을 쉽게 탐지할 수 없게 되었다.
더욱이 widget의 상태 공간을 더 복잡하게 만들었다: <code>uninit</code> 값을 가진 widget에는 어떤 처리가 허용(valid)되고 어떤 처리가 허용되지 않을까?</p>
<h5 id="note_5">Note</h5>
<p>어떨때는 람다를 초기화의 도구로 사용할수도 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
    <span class="n">Value</span> <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">();</span>   <span class="c1">// get_value()에서 pair&lt;error_code, Value&gt;를 반환한다</span>
        <span class="n">ec</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}();</span>
</code></pre></div>


<p>또는 이렇게 할수도 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">Value</span> <span class="n">v</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">();</span>   <span class="c1">// get_value()에서 pair&lt;error_code, Value&gt;를 반환한다</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> 
            <span class="k">throw</span> <span class="n">Bad_value</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">};</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}();</span>
</code></pre></div>


<h5 id="see-also">See also</h5>
<p><a href="#Res-lambda-init">ES.28</a></p>
<h5 id="enforcement_10">Enforcement</h5>
<ul>
<li>모든 초기화되지 않은 변수들을 지적한다.<br />
  기본 생성자를 가진 사용자 정의 타입 변수들은 지적하지 않는다.</li>
<li>초기화되지 않은 버퍼가 선언 <em>하자마자</em> 쓰기-접근 되는지 검사하라.<br />
  비-<code>const</code> 참조 실행인자(argument)로 전달하는 경우는 쓰기-접근으로 가정한다. </li>
</ul>
<h3 id="es21"><a name="Res-introduce"></a>ES.21: 사용할 필요가 없을 때 변수나 상수를 선언하지 마라</h3>
<h5 id="reason_11">Reason</h5>
<p>가독성.
변수가 사용될 수 있는 범위를 제한한다</p>
<h5 id="example_18">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="c1">// ... no use of x here ...</span>
    <span class="o">++</span><span class="n">x</span><span class="p">;</span>
</code></pre></div>


<h5 id="enforcement_11">Enforcement</h5>
<p>개체의 선언과 처음 사용되는 곳이 떨어져 있으면(distant from) 지적한다</p>
<h3 id="es22"><a name="Res-init"></a>ES.22: 변수를 초기화할 값이 생길 때까지 선언하지 마라</h3>
<h5 id="reason_12">Reason</h5>
<p>가독성. 변수가 사용될 수 있는 범위를 제한한다.
used-before-set의 위험을 감수하지 마라.
대입보다 초기화가 더 효율적일 수 있다.</p>
<h5 id="example-bad_7">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="c1">// ... s 를 사용하지 않는 부분 ...</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;what a waste&quot;</span><span class="p">;</span>
</code></pre></div>


<h5 id="example-bad_8">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">SomeLargeType</span> <span class="n">var</span><span class="p">;</span>  <span class="c1">// ugly CaMeLcAsEvArIaBlE </span>
                        <span class="c1">//      (Camel Case Variable)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span>   <span class="c1">// 좀 중요한 조건</span>
        <span class="n">Set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">cond2</span> <span class="o">||</span> <span class="o">!</span><span class="n">cond3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">Set2</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">something</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// var를 사용하는 코드; </span>
    <span class="c1">// 제어 흐름을 검파일 시간에 검사하는 방법으로 var를 너무 일찍 사용하지 않았다는 것을 알 수 있다</span>
</code></pre></div>


<p><code>SomeLargeType</code>의 기본 초기화 비용이 크다면 이 코드는 괜찮다고 할 수 있다.
그렇지 않다면, 어떤 프로그래머는 저 복잡한 조건 속에서 모든 경우가 고려되었는지 의심할 것이다. 만약 허점이 있다면, "use before set" 버그가 된다. 유지보수의 함정인 것이다.</p>
<p>중간정도 복잡한 초기화에 대해서는, <code>const</code> 변수를 포함해서, 초기화에 람다를 사용하는 것을 고려해보라; <a href="#Res-lambda-init">ES.28</a>를 참고하라.</p>
<h5 id="enforcement_12">Enforcement</h5>
<ul>
<li>처음 개체의 값을 읽기 전에 값을 대입하는 경우, 해당 개체가 기본 초기화로 선언되었으면 지적하라</li>
<li>초기화되지 않은 변수의 선언 이후에, 변수를 사용하기 전에 복잡한 처리(computation)이 있으면 지적하라</li>
</ul>
<h3 id="es23"><a name="Res-list"></a>ES.23: <code>{}</code> 초기화 문법을 사용하라</h3>
<h5 id="reason_13">Reason</h5>
<p><code>{}</code> 초기화를 사용하라는 규칙은 쉽고, 더 일반적이며, 덜 모호하고, 다른 초기화 형태에 비해 안전하다.</p>
<h5 id="example_19">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="mi">99</span><span class="p">)};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</code></pre></div>


<h5 id="exception_7">Exception</h5>
<p>컨테이너 타입들에 대해서는, <code>{...}</code>를 원소들을 나열하기 위해 사용하고 <code>(...)</code>는 크기를 나타내는데 사용한다는 전통(tradition)이 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="c1">// vector of 10 elements with the default value 0</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="p">{</span><span class="mi">10</span><span class="p">};</span>   <span class="c1">// vector of 1 element with the value 10</span>
</code></pre></div>


<h5 id="note_6">Note</h5>
<p><code>{}</code> 초기화는 값의 범위가 줄어드는 타입변환(narrowing conversion)을 허용하지 않는다.</p>
<h5 id="example_20">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mf">7.9</span><span class="p">};</span>   <span class="c1">// error: narrowing</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">7.9</span><span class="p">;</span>   <span class="c1">// OK: y becomes 7. Hope for a compiler warning</span>
</code></pre></div>


<h5 id="note_7">Note</h5>
<p><code>{}</code> 초기화는 다른 형태의 초기화와 달리 모든 경우의 초기화에 사용될 수 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>   <span class="c1">// initialized vector</span>

    <span class="n">D</span><span class="o">::</span><span class="n">D</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span><span class="n">m</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span> <span class="p">{</span>   <span class="c1">// member initializer </span>
                                    <span class="c1">// (e.g., m might be a pair)</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
    <span class="n">X</span> <span class="n">var</span> <span class="p">{};</span>   <span class="c1">// initialize var to be empty</span>
    <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>   <span class="c1">// default initializer for a member</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</code></pre></div>


<h5 id="note_8">Note</h5>
<p><code>auto</code>로 선언한 변수를 하나의 값으로 초기화 하는것, 예를 들어, <code>{v}</code>형태는 C++ 17 이전까지는 예상밖의 결과를 낳는다.
C++ 17의 규칙은 상대적으로 덜 놀랍다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">x1</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>    <span class="c1">// x1 is an int with the value 7</span>
    <span class="k">auto</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>  <span class="c1">// x2 is an initializer_list&lt;int&gt; with an element 7</span>

    <span class="k">auto</span> <span class="n">x11</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>    <span class="c1">// error: two initializers</span>
    <span class="k">auto</span> <span class="n">x22</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>  <span class="c1">// x2 is an initializer_list&lt;int&gt; with elements 7 and 8</span>
</code></pre></div>


<p>따라서 <code>initializer_list&lt;T&gt;</code>를 의도했다면 <code>={...}</code>를 사용하라.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">fib10</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">55</span><span class="p">};</span>   <span class="c1">// fib10 is a list</span>
</code></pre></div>


<h5 id="note_9">Note</h5>
<p>오래된 습관은 지우기 어렵다는 것을 생각하면, 이 규칙은 꾸준히 적용하기는 어렵다. 특히 <code>=</code>에 문제가 없는 경우가 너무나도 많다.</p>
<h5 id="example_21">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="n">x1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// T initialized with 1</span>
        <span class="n">T</span> <span class="nf">x0</span><span class="p">();</span>     <span class="c1">// bad: function declaration (often a mistake)</span>

        <span class="n">T</span> <span class="n">y1</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>   <span class="c1">// T initialized with 1</span>
        <span class="n">T</span> <span class="n">y0</span> <span class="p">{};</span>    <span class="c1">// default initialized T</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_13">Enforcement</h5>
<p>까다롭다(Tricky).</p>
<ul>
<li>단순한 초기화를 위한 <code>=</code>는 지적하지 않는다</li>
<li><code>auto</code> 이후에 <code>=</code>가 사용된 경우를 찾는다</li>
</ul>
<h3 id="es24-unique_ptrt"><a name="Res-unique"></a>ES.24: 포인터는 <code>unique_ptr&lt;T&gt;</code>에 담아라</h3>
<h5 id="reason_14">Reason</h5>
<p><code>std::unique_ptr</code>는 누수를 피하기 위한 가장 쉬운 방법이다.
이 방법은 믿을 수 있고, 타입 시스템이 안전한 소유권 관리를 위해 일하도록 만든다.
가독성을 향상시키고 실행시간 비용이 0에 가깝다.</p>
<h5 id="example_22">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="kt">bool</span> <span class="n">leak</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>   <span class="c1">// OK</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">};</span>            <span class="c1">// bad: might leak</span>

        <span class="c1">// ... no assignment to p2 ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">leak</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// ... no assignment to p2 ...</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                    <span class="c1">// exception thrown</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>만약 <code>leak</code>이 <code>true</code>값을 가진다면 <code>p2</code>가 가리키는 개체가 누수된다. 하지만 <code>p1</code>이 가리키는 개체는 그렇지 않다.
<code>at()</code>이 예외를 던지는 경우에도 그렇다.</p>
<h5 id="enforcement_14">Enforcement</h5>
<p><code>new</code>, <code>malloc()</code> 혹은 그 결과를 반환하는 함수의 대상이 되는 원시 포인터를 찾는다.</p>
<h3 id="es25-const-constexpr"><a name="Res-const"></a>ES.25: 값을 변경하지 않는다면 개체를 <code>const</code> 혹은 <code>constexpr</code>로 선언하라</h3>
<h5 id="reason_15">Reason</h5>
<p>실수로 값을 바꾸는 걸 막을 수 있는 방법이다.
컴파일러에게 최적화를 위한 기회를 줄 수도 있다.</p>
<h5 id="example_23">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">bufmax</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// good: bufmax가 이후의 코드에서 실수로 변경될 가능성이 없다</span>
        <span class="kt">int</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>                  <span class="c1">// suspicious: xmax를 나중에 바꾸려고 의도한 걸까?</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_15">Enforcement</h5>
<p>변수가 실제로 값이 바뀌는지 안 바뀌는지 보고 바뀐다면 지적한다.
불행하게도, <code>const</code>가 아닌 개체가 값을 바꾸려 <em>의도</em>했는지 찾아내는 것은 불가능하다.</p>
<h3 id="es26"><a name="Res-recycle"></a>ES.26: 서로 상관없는 목적에 하나의 변수를 사용하지 마라</h3>
<h5 id="reason_16">Reason</h5>
<p>가독성과 안전성</p>
<h5 id="example-bad_9">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* ... */</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bad: i 가 재사용된다</span>
            <span class="cm">/* ... */</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_10">Note</h5>
<p>초기화를 위해서, buffer를 재사용하고 싶을수도 있다.
하지만 그렇더라도 변수의 범위를 최대한 제한하고 buffer에 남겨진 데이터로 인해 버그가 발생하지 않도록 주의하라.
재사용된 버퍼는 보안관련 버그의 원인이 되기도 한다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">write_to_file</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buffer</span><span class="p">;</span>             <span class="c1">// to avoid reallocations on every loop iteration</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">o</span> <span class="p">:</span> <span class="n">objects</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// First part of the work.</span>
            <span class="n">generate_first_String</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
            <span class="n">write_to_file</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

            <span class="c1">// Second part of the work.</span>
            <span class="n">generate_second_string</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
            <span class="n">write_to_file</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

            <span class="c1">// etc...</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_16">Enforcement</h5>
<p>재활용되는 변수가 있다면 지적한다.</p>
<h3 id="es27-stdarray-stack_array"><a name="Res-stack"></a>ES.27: 스택에서 사용되는 배열은 <code>std::array</code>나 <code>stack_array</code>를 사용하라</h3>
<h5 id="reason_17">Reason</h5>
<p>가독성이 높아지고, 묵시적으로 포인터로 바뀌지 않는다.
언어가 지원하는 배열의 비표준적인 확장과 헷갈리지 않는다.</p>
<h5 id="example-bad_10">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a1</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">a2</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>   <span class="c1">// error: ISO C++가 아니다</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_11">Note</h5>
<p><code>a1</code> 변수선언은 C++에서는 적법하다. 이 방법을 사용한 코드가 많이 있다.
다만 이는 길이 값이 비지역 변수인 경우 잘못 사용하기 쉽다. 버퍼 오버플로우, 배열을 포인터로 변환하는 등의 "유명한" 오류 원인이 된다.</p>
<p><code>a2</code> 변수선언은 C 방식으로 C++ 에서는 쓰지 않으며 보안상 문제가 있는 것으로 간주한다.</p>
<h5 id="example_24">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">;</span>
        <span class="n">stack_array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_17">Enforcement</h5>
<ul>
<li>상수 길이를 가지지 않는 배열이라면 지적한다. (C 언어의 가변길이배열(VLA))</li>
<li>배열 길이로 지역 상수를 사용하지 않으면 지적한다</li>
</ul>
<h3 id="es28-const"><a name="Res-lambda-init"></a>ES.28: 복잡한 초기화, 특히 <code>const</code> 변수의 초기화에는 람다를 사용하라</h3>
<h5 id="reason_18">Reason</h5>
<p>멋지게 지역 초기화를 숨길 수 있다.
초기화 작업을 위해서만 필요한 변수를 포함해서 재사용할 것 같지 않은 함수를 생성할 필요도 없다.</p>
<p>약간의 초기화 작업 후에 <code>const</code>여야 하는 변수에도 사용할 수 있다.</p>
<h5 id="example-bad_11">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">widget</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// 가능하다면 const여야 한다, 하지만:</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>          <span class="c1">// 이 부분이 x를 초기화하기 위한</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">some_obj</span><span class="p">.</span><span class="n">do_something_with</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// 좀 긴 코드라고 하자</span>
    <span class="p">}</span>
    <span class="c1">// 이 지점부터, x는 const가 되어야 한다. </span>
    <span class="c1">// 하지만 이런 코딩 스타일에서는 그렇게 만들 수가 없다.</span>
</code></pre></div>


<h5 id="example-good">Example, good</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">const</span> <span class="n">widget</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span>
        <span class="n">widget</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// widget이 기본 생성자를 가진다고 가정하자</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>            <span class="c1">// 이 부분이 x를 초기화하기 위한</span>
            <span class="n">val</span> <span class="o">+=</span> <span class="n">some_obj</span><span class="p">.</span><span class="n">do_something_with</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// 좀 긴 코드라고 하자</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}();</span>
</code></pre></div>


<h5 id="example_25">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">string</span> <span class="n">var</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">)</span> <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>   <span class="c1">// default</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}();</span> <span class="c1">// note ()</span>
</code></pre></div>


<p>가능하다면 <code>enum</code>같은 쉬운 방법으로 조건을 줄여라. 분기 선택과 초기화를 뒤섞어선 안된다.</p>
<h5 id="enforcement_18">Enforcement</h5>
<p>어렵다. 잘 해도 경험적인(heuristic) 수준. 
루프를 사용해 값을 설정하는 초기화 안된 변수을 찾아라.</p>
<h3 id="es30-manipulate"><a name="Res-macros"></a>ES.30: 프로그램 텍스트를 다루기(manipulate) 위해 매크로를 사용하지 마라</h3>
<h5 id="reason_19">Reason</h5>
<p>매크로는 버그의 주요 원인이다.
매크로는 일반적인 범위와 타입 규칙을 따르지 않는다.
매크로는 사람이 보는 것과 컴파일러가 보는 것을 다르게 한다.
매크로는 지원 도구를 만드는 것을 복잡하게 한다.</p>
<h5 id="example-bad_12">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="cp">#define Case break; case   </span><span class="cm">/* BAD */</span><span class="cp"></span>
</code></pre></div>


<p>이 문제 없어 보이는 매크로는 <code>C</code>대신 <code>c</code>가 사용되면 악질적인(bad) 제어흐름 버그로 이어진다.</p>
<h5 id="note_12">Note</h5>
<p>이 규칙은 <code>#ifdef</code>문에서 설정제어를 위해 매크로를 사용하는 것은 막지 않는다.</p>
<p>미래에 모듈이 도입되면 설정을 제어하기 위한 매크로는 사라지게 될 것이다.</p>
<h5 id="note_13">Note</h5>
<p>이 규칙이 의도하는 것은 <code>#</code>을 사용해 문자를 만들어내거나 <code>##</code>를 사용해 접합(concat)하는 것이다. 
보통의 매크로들 처럼, "거의 무해한" 경우도 있다. 하지만 자동 완성기, 정적 분석기, 디버거와 같은 도구에게는 문제가 된다.</p>
<p>경우에 따라서는 근사한 매크로를 사용하는 것이 과도하게 복잡한 설계가 있다는 신호일 수 있다.
또한, <code>#</code>와 <code>##</code>를 사용하면 매크로를 정의하고 사용하도록 유도(encourage)한다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="cp">#define CAT(a, b) a ## b</span>
    <span class="cp">#define STRINGIFY(a) #a</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">CAT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;asdf&quot;</span><span class="p">;</span>   <span class="c1">// BAD: 툴에서 다루기 어렵다 (그리고 못생겼다)</span>
        <span class="n">string</span> <span class="n">sx2</span> <span class="o">=</span> <span class="n">STRINGIFY</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>매크로없이 문자열을 조작하기 위한 방법(workaround)이 있다.
예를 들자면:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;asdf&quot;</span> <span class="s">&quot;lkjh&quot;</span><span class="p">;</span>   <span class="c1">// 평범한 문자열 리터럴 접합 (literal concatenation)</span>

    <span class="k">enum</span> <span class="n">E</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">x</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">stringify</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">a</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;a&quot;</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">b</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;b&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">sx</span> <span class="o">=</span> <span class="n">stringify</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>매크로만큼 편리한 것은 아니지만, 쉽게 사용할 수 있고, 오버헤드를 발생시키지 않으며, 타입과 유효범위의 영향을 받는다.</p>
<p>미래에는 정적 리플렉션(static reflection)이 전처리기를 사용해 문자열을 다루는 것을 없애게 될 것이다.</p>
<h5 id="enforcement_19">Enforcement</h5>
<p>소스제어(<code>#ifdef</code>같은)에 사용하지 않는 매크로를 본다면 소리를 질러라.</p>
<h3 id="es31"><a name="Res-macros2"></a>ES.31: 매크로를 상수나 "함수"에 사용하지 마라</h3>
<h5 id="reason_20">Reason</h5>
<p>매크로는 버그의 주요 원인이다.<br />
매크로는 일반적인 범위와 타입 규칙을 따르지 않는다.<br />
매크로는 사람이 보는 것과 컴파일러가 보는 것을 다르게 한다.<br />
매크로는 지원 도구를 만드는 것을 복잡하게 한다.  </p>
<h5 id="example-bad_13">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="cp">#define PI 3.14</span>
    <span class="cp">#define SQUARE(a, b) (a * b)</span>
</code></pre></div>


<p><code>SQUARE</code>에 잘 알려진 버그가 없다고 하더라도 더 잘 동작하는 대안이 있다.</p>
<p>예를 들면:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
    <span class="n">T</span> <span class="n">square</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_20">Enforcement</h5>
<p>소스제어(<code>#ifdef</code>같은)에 사용하지 않는 매크로를 본다면 소리를 질러라.</p>
<h3 id="es32-all_caps"><a name="Res-ALL_CAPS"></a>ES.32: 모든 매크로는 <code>ALL_CAPS</code> 형태로 선언하라</h3>
<h5 id="reason_21">Reason</h5>
<p>관습. 가독성. 매크로 구별.</p>
<h5 id="example_26">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="cp">#define forever for (;;)   </span><span class="cm">/* 엄청 나쁜 코드 */</span><span class="cp"></span>

    <span class="cp">#define FOREVER for (;;)   </span><span class="cm">/* 여전히 사악하지만, 최소한 사람은 매크로라는걸 알 수 있다 */</span><span class="cp"></span>
</code></pre></div>


<h5 id="enforcement_21">Enforcement</h5>
<p>소문자로 작성된 매크로를 본다면 소리를 질러라.</p>
<h3 id="es33"><a name="Res-MACROS"></a>ES.33: 매크로를 사용해야만 한다면, 고유한 이름을 사용하라</h3>
<h5 id="reason_22">Reason</h5>
<p>매크로는 유효범위 규칙을 따르지 않는다.</p>
<h5 id="example_27">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="cp">#define MYCHAR        </span><span class="cm">/* BAD, will eventually clash with someone else&#39;s MYCHAR*/</span><span class="cp"></span>

    <span class="cp">#define ZCORP_CHAR    </span><span class="cm">/* Still evil, but less likely to clash */</span><span class="cp"></span>
</code></pre></div>


<h5 id="note_14">Note</h5>
<p>가능하다면 매크로는 사용하지 마라: <a href="#Res-macros">ES.30</a>, <a href="#Res-macros2">ES.31</a>, 그리고 <a href="#Res-ALL_CAPS">ES.32</a>를 참고하라.</p>
<p>안타깝게도, 매크로를 사용하거나 남용하는 긴 전통과 함께 매크로의 영향을 받는 코드가 수십억 줄은 있을 것이다. 매크로를 사용해야만 한다면, 긴 이름을 사용하고 고유한 접두사(prefix)를 붙여서 (당신이 속한 조직의 이름이라던지) 이름이 충돌할 가능성을 낮춰라.</p>
<h5 id="enforcement_22">Enforcement</h5>
<p>짧은 매크로 이름에 대해서 경고하라.</p>
<h3 id="es34-c-"><a name="Res-ellipses"></a> ES.34: (C-스타일의) 가변인자 함수를 정의하지 마라</h3>
<h5 id="reason_23">Reason</h5>
<p>타입 안전하지 않다.
정확하게 동작하기 위해서 지저분한 변환/매크로 코드가 필요하다.</p>
<h5 id="example_28">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="cp">#include</span> <span class="cpf">&lt;cstdarg&gt;</span><span class="cp"></span>

    <span class="c1">// &quot;severity&quot; followed by a zero-terminated list of char*s; </span>
    <span class="c1">// write the C-style strings to cerr</span>
    <span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="kt">int</span> <span class="n">severity</span> <span class="p">...)</span>
    <span class="p">{</span>
        <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>             <span class="c1">// a magic type for holding arguments</span>
        <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">severity</span><span class="p">);</span> <span class="c1">// arg startup: &quot;severity&quot; is the first argument of error()</span>

        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="c1">// treat the next var as a char*; no checking: a cast in disguise</span>
            <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>             <span class="c1">// arg cleanup (don&#39;t forget this)</span>

        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">severity</span><span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="n">severity</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">&quot;this&quot;</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="s">&quot;an&quot;</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
        <span class="n">error</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// crash</span>
        <span class="n">error</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">&quot;this&quot;</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="s">&quot;an&quot;</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">);</span>  <span class="c1">// crash</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">is</span> <span class="o">=</span> <span class="s">&quot;is&quot;</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">an</span> <span class="o">=</span> <span class="s">&quot;an&quot;</span><span class="p">;</span>
        <span class="n">error</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">&quot;this&quot;</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="n">an</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">);</span> <span class="c1">// crash</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="alternative">Alternative</h5>
<p>중복 정의, 템플릿, 가변 템플릿을 사용하라</p>
<div class="codehilite"><pre><span></span><code>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="kt">int</span> <span class="n">severity</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="n">severity</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">error</span><span class="p">(</span><span class="kt">int</span> <span class="n">severity</span><span class="p">,</span> <span class="n">T</span> <span class="n">head</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span> <span class="n">tail</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">error</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span> <span class="n">tail</span><span class="p">...);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// No crash!</span>
        <span class="n">error</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;this&quot;</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="s">&quot;not&quot;</span><span class="p">,</span> <span class="s">&quot;an&quot;</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">);</span> <span class="c1">// No crash!</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">an</span> <span class="o">=</span> <span class="s">&quot;an&quot;</span><span class="p">;</span>
        <span class="n">error</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">&quot;this&quot;</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="s">&quot;not&quot;</span><span class="p">,</span> <span class="n">an</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">);</span> <span class="c1">// No crash!</span>

        <span class="n">error</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;oh&quot;</span><span class="p">,</span> <span class="s">&quot;no&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span> <span class="c1">// Compile error! No need for nullptr.</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_15">Note</h5>
<p>이 방법으로 <code>printf</code>가 구현되어있다.</p>
<h5 id="enforcement_23">Enforcement</h5>
<ul>
<li>C-스타일 가변인자 함수를 정의하면 지적하라</li>
<li><code>#include &lt;cstdarg&gt;</code>와 <code>#include &lt;stdarg.h&gt;</code>를 지적하라</li>
</ul>
<h2 id="esexpr">ES.expr: 표현식</h2>
<p>표현식은 값을 조작한다(manipulate).</p>
<h3 id="es40"><a name="Res-complicated"></a>ES.40: 복잡한 표현식을 피하라</h3>
<h5 id="reason_24">Reason</h5>
<p>표현식이 복잡하면 오류가 발생하기 쉽다.</p>
<h5 id="example_29">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// bad: assignment hidden in subexpression</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">// bad: two non-local variables assigned in a sub-expressions</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">c1</span><span class="p">,</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">c2</span><span class="p">),</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="p">)</span>

    <span class="c1">// better, but possibly still too complicated</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">c1</span> <span class="o">&gt;&gt;</span> <span class="n">c2</span> <span class="o">&amp;&amp;</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="p">;)</span>

    <span class="c1">// OK: if i and j are not aliased</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">++</span><span class="n">i</span> <span class="o">+</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span>

    <span class="c1">// OK: if i != j and i != k</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

    <span class="c1">// bad: multiple assignments &quot;hidden&quot; in subexpressions</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">())</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">g</span><span class="p">())</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>

    <span class="c1">// bad: relies on commonly misunderstood precedence rules</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">&amp;&amp;</span> <span class="n">e</span> <span class="o">^</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">7</span><span class="p">;</span>

    <span class="c1">// bad: undefined behavior</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">++</span> <span class="o">+</span> <span class="n">x</span><span class="o">++</span> <span class="o">+</span> <span class="o">++</span><span class="n">x</span><span class="p">;</span>
</code></pre></div>


<p>위의 연산식 중 몇은 의심의 여지없이 나쁘다. (정의되지 않은 행동이 일어나게 한다)
나머지는 꽤 복잡하거나 특이한 편이고, 심지어 능력있는 프로그래머도 잘못 이해하거나 문제를 간과해 버릴 만한 것도 있다.</p>
<h5 id="note_16">Note</h5>
<p>C++17 에서는 평가 순서를 규정하고 있다.<br />
오른쪽에서 왼쪽으로 대입되는 것을 제외하고 왼쪽에서 오른쪽 순서로 평가된다. 
함수의 실행인자 평가순서는 정의되어 있지 않다; <a href="#Res-order">ES.43 를 참고하라</a>
하지만 이 규칙의 유무가 복잡한 표현식이 혼란을 만든다는 사실을 바꾸지는 않는다.</p>
<h5 id="note_17">Note</h5>
<p>프로그래머는 표현식의 기본적인 규칙들을 알고 사용해야 한다.</p>
<h5 id="example_30">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">x</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>      <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>    <span class="c1">// bad: 불필요하게 장황한 코드</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span>   <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// bad: 불필요하게 장황한 코드</span>
    <span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">&amp;&amp;</span> <span class="n">t2</span><span class="p">)</span>            <span class="c1">// ...</span>
</code></pre></div>


<h5 id="enforcement_24">Enforcement</h5>
<p>까다롭다. "표현식이 얼마나 복잡한가"를 어떻게 판단할 것인가? 어떻게 고려할 것인가? 
계산을 하나의 연산으로만 구성된 문장들로 구성하기는 힘들다.</p>
<p>고려할만한 것들:
* 부수 효과(side-effect): 다수의 비지역 변수에 대한 부수 효과을 의심할 수 있다. 특히 별도의 하위 연산식에 있는 경우
* 별명용 변수(aliased variable)에 값을 쓰는 행위
* N개 이상의 연산자 (N은 얼마가 되어야 하는가?)
* 미묘한 우선순위규칙에 의존하기
* 미정의 행동 (undefined behavior: 모든 미정의 행동을 잡아낼 수 있는가?)
* 구현에 따라 달라지는 행동(implementation defined behavior)?
* ???</p>
<h3 id="es41-parenthesize"><a name="Res-parens"></a>ES.41: 연산자 우선순위가 불분명하면, 소괄호를 사용하라(parenthesize)</h3>
<h5 id="reason_25">Reason</h5>
<p>오류가 발생하지 않게 하라. 가독성. 모든 사람들이 연산자 우선순위를 기억하지는 않는다.</p>
<h5 id="example_31">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">flag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// bad: a &amp; (flag != 0)를 의도했다</span>
</code></pre></div>


<h5 id="note_18">Note</h5>
<p>프로그래머는 산술 연산, 논리 연산에 대해서 우선순위 테이블을 알고 있을 것을 기대한다.
다른 연산과 비트 연산을 섞어 사용할 때는 소괄호(parentheses)를 사용하기를 권한다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// OK: 의도대로 동작한다</span>
</code></pre></div>


<h5 id="note_19">Note</h5>
<p>아래에 대해서는 소괄호가 필요없다는 정도는 알고 있을 것이다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_25">Enforcement</h5>
<ul>
<li>비트 논리 연산자와 다른 연산자가 섞여 있다면 지적한다</li>
<li>가장 왼쪽에 위치한 연산자(leftmost operator)가 할당 연산자가 아니라면 지적한다</li>
<li>???</li>
</ul>
<h3 id="es42"><a name="Res-ptr"></a>ES.42: 포인터는 간단하고 직관적인 형태로 사용하라</h3>
<h5 id="reason_26">Reason</h5>
<p>복잡한 포인터 계산은 주요한 오류 원인이 된다.</p>
<h5 id="note_20">Note</h5>
<p>포인터 대신 <code>gsl::span</code>를 사용하라.
포인터는 <a href="../Interfaces/#Ri-array">오직 하나의 개체를 가리킬 때만 사용해야 한다</a>.
포인터의 산술연산은 잘못 사용하기 쉽고 수많은, 수많은 나쁜 버그와 보안  위험(violation)의 원인이다.
<code>span</code>은 경계를 검사하고, 안전하게 배열의 데이터에 접근하는 타입이다.
경계를 알 수 있는 배열에 대한 접근(subscript)에 상수를 사용하는 코드는 컴파일러가 평가할 수 있다.</p>
<h5 id="example-bad_14">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="kt">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// BAD</span>

        <span class="kt">ptrdiff_t</span> <span class="n">d</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>      <span class="c1">// OK</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>       <span class="c1">// OK</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>      <span class="c1">// BAD</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// BAD</span>

        <span class="n">p</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// BAD</span>

        <span class="n">use</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>     <span class="c1">// BAD</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-good_1">Example, good</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// BETTER: 함수 선언에서 span을 사용해버린다</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>      <span class="c1">// OK</span>

        <span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// OK</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// OK</span>

        <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// OK</span>

        <span class="n">use</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>  <span class="c1">// OK</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_21">Note</h5>
<p>변수를 사용해 배열에 접근하는 코드가 안전한지 평가하는 것은 도구와 사람 모두에게 어렵다.
<code>span</code>은 실행 시간에 경계를 검사하기 때문에, 배열의 데이터에 접근할때 안전하다.
<code>at()</code>은 한번 접근할 때 경계를 검사하는 다른 방법이다.
배열에 접근할 때 반복자가 필요하다면, 배열에 대한 <code>span</code>을 생성하고 그에 대한 반복자를 사용하라.</p>
<h5 id="example-bad_15">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">pos</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// BAD</span>
        <span class="n">a</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// BAD</span>
        <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1">// BAD (다만 도구에서 잡아낼 수 있다) -- 다른 방법이 없다. 그냥 이런 코드를 작성하지 마라</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>    <span class="c1">// BAD (다만 도구에서 잡아낼 수 있다) -- 다른 방법이 없다. 그냥 이런 코드를 작성하지 마라</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-good_2">Example, good</h5>
<p><code>span</code>을 사용하면 이렇다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// A1: 매개변수 타입을 span을 사용하도록 바꾸었다</span>
    <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">pos</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// OK</span>
        <span class="n">a</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span>

    <span class="c1">// A2: 지역변수로 span을 만들어 사용한다</span>
    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="n">arr</span><span class="p">,</span> <span class="n">pos</span><span class="p">};</span>
        <span class="n">a</span><span class="p">[</span><span class="n">pos</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// OK</span>
        <span class="n">a</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span>
</code></pre></div>


<p><code>at()</code>을 사용하면 이렇다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// ALTERNATIVE B: 원소에 접근할때 at()을 사용한다</span>
    <span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pos</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// OK</span>
        <span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-bad_16">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">COUNT</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// BAD, cannot use non-constant indexer</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-good_3">Example, good</h5>
<p><code>span</code>을 사용하면 이렇다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">COUNT</span><span class="p">];</span>
        <span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">av</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">av</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>범위 기반 <code>for</code>문에 <code>span</code>을 사용하면 이렇다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f1a</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">COUNT</span><span class="p">];</span>
         <span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">COUNT</span><span class="o">&gt;</span> <span class="n">av</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
         <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">av</span><span class="p">)</span>
             <span class="n">e</span> <span class="o">=</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>접근할 때 <code>at()</code>를 사용하면 이렇다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f2</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">COUNT</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">at</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>범위기반 <code>for</code>문은 이렇다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f3</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">COUNT</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">arr</span><span class="p">)</span>
             <span class="n">e</span> <span class="o">=</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_22">Note</h5>
<p>도구에서 실행시간에 결정되는 인덱스로 배열에 접근하는 표현식을 <code>at()</code>을 사용해 다시 작성하도록 할수도 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>      <span class="c1">// BAD, 이 코드를 다시 쓴다면 ...</span>
        <span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>  <span class="c1">// OK -- 경계를 검사한다</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example_32">Example</h5>
<p>(그동안 언어에서 해왔던 것처럼) 배열을 포인터로 바꾸는 것은 경계 검사의 기회를 없애버린다. 지양하라.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
        <span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// BAD: 배열 개체를 넘기려 한것일까?</span>
        <span class="n">g</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>    <span class="c1">// OK: 개체를 넘기고 있다</span>
    <span class="p">}</span>
</code></pre></div>


<p>배열을 전달하고 싶다면:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">);</span>  <span class="c1">// 오래된 (위험한) 코드</span>

    <span class="kt">void</span> <span class="nf">g1</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">av</span><span class="p">);</span> <span class="c1">// BETTER: get g() changed.</span>

    <span class="kt">void</span> <span class="nf">f2</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
        <span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">av</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

        <span class="n">g</span><span class="p">(</span><span class="n">av</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">av</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>    <span class="c1">// OK, 선택의 여지가 없다면</span>
        <span class="n">g1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>                      <span class="c1">// OK -- 배열에서 포인터로의 decay가 발생하지 않는다.</span>
                                    <span class="c1">// 대신 span을 생성한다</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_26">Enforcement</h5>
<ul>
<li>포인터 타입에 대한 산술연산을 수행하는 표현식은 지적하라</li>
<li>배열(정적 배열 혹은 <code>std::array</code>)에 인덱스를 사용해 접근하는 표현식을 지적하라. 이때 표현식은 배열 범위 안(<code>0</code>부터 배열 끝까지)에 해당하는 컴파일 시간 상수 표현식이 아니어야 한다</li>
<li>배열 타입에서 포인터 타입으로 묵시적 형변환에 의존하는 표현식을 지적하라</li>
</ul>
<p>이 규칙은 <a href="../Profile/#SS-bounds">경계 안전성 검사</a>의 일부분이다.</p>
<h3 id="es43"><a name="Res-order"></a>ES.43: 평가 순서가 정의되지 않은 표현식은 사용하지 마라</h3>
<h5 id="reason_27">Reason</h5>
<p>그런 코드가 어떻게 동작할지는 알 수가 없다. 이식성.
특정한 환경에는 맞을지는 몰라도, 다른 컴파일러 (혹은 사용 중인 컴파일러의 다음 버전)에서는 다를 수 있다. 
혹은 최적화 설정에 따라 다를 수도 있다.</p>
<h5 id="note_23">Note</h5>
<p>C++17 에서는 평가 순서를 규정하고 있다.<br />
오른쪽에서 왼쪽으로 대입되는 것을 제외하고 왼쪽에서 오른쪽 순서로 평가된다. 
함수의 실행인자 평가순서는 정의되어 있지 않다.</p>
<p>당신의 코드가 (Ctrl + C,V 되어서) C++ 17 이전의 컴파일러로 컴파일 될 수 있다는 것을 기억하라. 너무 영리할 필요는 없다.</p>
<h5 id="example_33">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span>   <span class="c1">// 결과는 알 수 없다(undefined)</span>
</code></pre></div>


<p>가장 좋은 규칙은 값을 변경하는 표현식에서 값을 읽지 않는 것이다.</p>
<h5 id="enforcement_27">Enforcement</h5>
<p>좋은 분석기를 사용해 찾을 수 있다.</p>
<h3 id="es44"><a name="Res-order-fct"></a>ES.44: 함수 인자가 표현식 평가 순서의 영향을 받지 않게 하라</h3>
<h5 id="reason_28">Reason</h5>
<p>순서가 정의되어있지 않다.</p>
<h5 id="note_24">Note</h5>
<p>C++17 에서는 평가 순서를 규정하고 있다.<br />
오른쪽에서 왼쪽으로 대입되는 것을 제외하고 왼쪽에서 오른쪽 순서로 평가된다. 
함수의 실행인자 평가순서는 정의되어 있지 않다.</p>
<h5 id="example_34">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span>
</code></pre></div>


<p>이 함수 호출은 <code>f(0, 1)</code>혹은 <code>f(1, 0)</code>일 것이다. 하지만 어떤 것이 될지는 알 수 없다.
기술적으로는, 어떻게 처리해야 하는지 정의되어 있지 않다.</p>
<p>C++ 17에서는 이 코드가 미정의 행동이 아니다. 하지만 여전히 어떤 인자가 먼저 평가되는지 분명하지 않다.</p>
<h5 id="example_35">Example</h5>
<p>중복정의된 연산자들은 평가순서 문제로 이어질 수 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">f1</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">(</span><span class="n">f2</span><span class="p">());</span>          <span class="c1">// m( f1(), f2() )</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span><span class="p">();</span>   <span class="c1">// operator&lt;&lt;( operator&lt;&lt;( cout, f1() ), f2() )</span>
</code></pre></div>


<p>C++ 17에서 이 예시는 기대한 대로 동작한다 (왼쪽에서 오른쪽으로 평가된다).
그리고 <code>=</code>의 바인딩이 오른쪽에서 왼쪽으로 수행되는 것처럼 대입은 오른쪽에서 왼쪽으로 평가된다. </p>
<div class="codehilite"><pre><span></span><code>    <span class="n">f1</span><span class="p">()</span> <span class="o">=</span> <span class="n">f2</span><span class="p">();</span>    <span class="c1">// C++14 에서는 미정의 행동; </span>
                    <span class="c1">// C++17 에서는 f2()가 f1()보다 먼저 평가된다</span>
</code></pre></div>


<h5 id="enforcement_28">Enforcement</h5>
<p>좋은 분석기를 사용해 찾을 수 있다.</p>
<h3 id="es45-magic-constant"><a name="Res-magic"></a>ES.45: 이유를 알 수 없는 상수(magic constant)를 사용하지 마라; 상징적인 상수를 사용하라</h3>
<h5 id="reason_29">Reason</h5>
<p>표현식에 포함된 이름없는 상수는 간과되기 쉽고 이해하기 어렵다:</p>
<h5 id="example_36">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span>   <span class="c1">// don&#39;t: 상수 12는 무엇을 의미하는가?</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">month</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>


<p>1년에 12달이 숫자로만 되어 있다면 이해가 잘 안될 것이다. </p>
<p>더 좋게 고치면:</p>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// 1..12를 사용해서 12개월을 표현한다</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">first_month</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">last_month</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">first_month</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">last_month</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span>   <span class="c1">// better</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">month</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>


<p>아예 상수를 사용하지 않으면 더 낫다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">m</span> <span class="p">:</span> <span class="n">month</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>


<h5 id="enforcement_29">Enforcement</h5>
<p>코드에 리터럴이 있다면 지적한다. <code>0</code>, <code>1</code>, <code>nullptr</code>, <code>\n</code>, <code>""</code> 등 가능한 목록은 허용하라.</p>
<h3 id="es46"><a name="Res-narrowing"></a>ES.46: 타입 범위를 축소하는 변환을 피하라</h3>
<h5 id="reason_30">Reason</h5>
<p>정보를 파괴하고 전혀 기대하지 않은 값을 가지게 한다.</p>
<h5 id="example-bad_17">Example, bad</h5>
<p>기본적인 예제:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">7.9</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// bad: 축소 변환: i가 7이 된다</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">d</span><span class="p">;</span>  <span class="c1">// bad: 이렇게 하더라도 충분히 분명하지 않다</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// bad: narrowing</span>
        <span class="kt">char</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>   <span class="c1">// bad: narrowing</span>
        <span class="kt">char</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>   <span class="c1">// bad: narrowing</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_25">Note</h5>
<p>gsl은 narrowing을 허용하는 <code>narrow_cast</code>와 변환시 값이 바뀌면 예외를 던지는 <code>narrow</code>("narrow if")를 제공한다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">i</span> <span class="o">=</span> <span class="n">narrow_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>   <span class="c1">// OK (you asked for it): narrowing: i becomes 7</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">narrow</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>        <span class="c1">// OK: throws narrowing_error</span>
</code></pre></div>


<p>이 규칙은 부동 소수점 타입의 음수를 부호 없는 정수타입으로 변환하는 등의 손실있는 형변환까지도 포함한다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="mf">7.9</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>                          <span class="c1">// BAD</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">narrow_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>   <span class="c1">// OK (you asked for it): u becomes 0</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">narrow</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>        <span class="c1">// OK: throws narrowing_error</span>
</code></pre></div>


<h5 id="enforcement_30">Enforcement</h5>
<p>좋은 분석기는 범위가 축소되는 변환을 탐지할 수 있다.
하지만 모든 축소변환을 지적하는 것은 수많은 거짓 양성(false positive)로 이어질 것이다. </p>
<p>제안:</p>
<ul>
<li>부동 소수점에서 정수로의 변환을 지적한다 (<code>float</code>-&gt;<code>char</code> 이나 <code>double</code>-&gt;<code>int</code>만 지적할수도 있다. 더 많은 정보가 필요하다)</li>
<li>모든 <code>long</code>-&gt;<code>char</code> 변환을 지적한다. (<code>int</code>-&gt;<code>char</code> 변환은 상당히 일반적이다. 더 많은 정보가 필요하다)</li>
<li>함수의 실행인자에서 축소 변환이 발생하면 특히 의심스럽게 생각한다</li>
</ul>
<h3 id="es47-0-null-nullptr"><a name="Res-nullptr"></a>ES.47: <code>0</code> 혹은 <code>NULL</code>보다는 <code>nullptr</code>를 사용하라</h3>
<h5 id="reason_31">Reason</h5>
<p>가독성의 문제다. 기대를 벗어나지 않게 한다.</p>
<p><code>nullptr</code>는 <code>int</code>와 혼동의 여지가 없다. 
<code>nullptr</code>는 잘 명세된 (아주 까다로운) 타입을 가지고 있다. 그러니 <code>NULL</code> 혹은 <code>0</code>을 사용하면 잘못될 수 있는 타입 추론 상황에서 더 잘 동작할 것이다.</p>
<h5 id="example_37">Example</h5>
<p>참고하라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
    <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>         <span class="c1">// f(int)</span>
    <span class="n">f</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>   <span class="c1">// f(char*)</span>
</code></pre></div>


<h5 id="enforcement_31">Enforcement</h5>
<p>포인터에 <code>0</code>, <code>NULL</code>을 사용한다면 지적한다. 프로그램으로 간단하게 변환할 수 있으면 도움이 될 것이다.</p>
<h3 id="es48-cast"><a name="Res-casts"></a>ES.48: 타입 변환(cast)을 피하라</h3>
<h5 id="reason_32">Reason</h5>
<p>잘 알려진 오류의 원인이다. 최적화를 신뢰할 수 없게 만들어 버린다.</p>
<h5 id="example-bad_18">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">q</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>


<p>이 코드는 어떤 값을 출력할까?
The result is at best implementation defined. 
필자의 환경에서는 이런 결과가 나온다</p>
<div class="codehilite"><pre><span></span><code>    2 0 4611686018427387904
</code></pre></div>


<p>아래의 내용을 더하면,</p>
<div class="codehilite"><pre><span></span><code>    <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">q</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>


<p>이런 결과가 나온다</p>
<div class="codehilite"><pre><span></span><code>    3.29048e-321 666 666
</code></pre></div>


<p>놀라운가? 프로그램에서 크래시나 생기지 않은게 다행이다.</p>
<h5 id="note_26">Note</h5>
<p>타입 변환을 작성하는 프로그래머는 자신이 무엇을 하고있는지 안다고 생각한다. 또는 값을 사용할때 일반적인 규칙들을 접어두기도 한다.</p>
<p>중복정의 선택(overload resolution)이나 템플릿 실체화(instantiation)는 보통 인자 타입이 꼭 맞는 함수를 골라낸다. 그런 함수가 없다면, 어쩌면 고쳐서(local fix) 적용할 필요가 있을지도 모르지만, 오류가 된다.</p>
<h5 id="note_27">Note</h5>
<p>형변환은 시스템 프로그래밍 언어에 꼭 필요하다.
예를 들어, 디바이스 레지스터의 주소를 포인터로 얻어 올 때이다.
그러나 너무 남용하는 바람에 많은 오류가 발생하는 것도 사실이다.</p>
<h5 id="note_28">Note</h5>
<p>형변환을 너무 많이 쓴다고 생각된다면 설계에 근본적인 문제가 있을지도 모른다.</p>
<h5 id="exception_8">Exception</h5>
<p><code>(void)</code>로 타입을 변환하는 것은 <code>[nodiscard]]</code>경고를 막기 위해 표준에서 허용하는 방법은 아니다.
<code>[[nodiscard]]</code> 속성이 있는 함수를 호출하면서 반환 결과를 버리기를 원한다면,
우선 그 생각이 정말 좋은 생각인지 진지하게 고민하라
(무엇보다 함수의 반환 타입에 <code>[[nodiscard]]</code>를 작성한데는 보통 타당한 이유가 있다),
하지만 당신이 값을 버려도 적절하다고 생각하고, 당신과 함께 코드를 리뷰한 사람들이 동의한다면 <code>(void)</code>를 써서 경고를 없애라.</p>
<h5 id="alternatives">Alternatives</h5>
<p>타입 변환은 널리 (잘못) 사용되고 있다. 모던 C++은 규칙을 두고 여러 방법으로 타입 변환이 필요 없도록 한다.</p>
<ul>
<li>템플릿을 사용한다</li>
<li><code>std::variant</code>을 사용한다</li>
<li>포인터 타입 간의 잘 정의되고, 안전하고, 묵시적인 변환을 사용한다</li>
</ul>
<h5 id="enforcement_32">Enforcement</h5>
<ul>
<li><code>[[nodiscard]]</code>로 반환하는 함수를 제외하고 C-스타일 타입 변환을 없애도록 강제한다</li>
<li>함수 형태로 변환하는 일이 빈번하면 경고하라('많이' 하는 시점에서 분명 문제가 있다)</li>
<li><a href="../Profile/#Pro-type-reinterpretcast">타입 안전성 프로필</a>은 <code>reinterpret_cast</code>를 금지한다</li>
<li>포인터 타입 간의 <a href="../Profile/#Pro-type-identitycast">동일 타입 형변환</a>은 경고하라</li>
<li>포인터가 <a href="../Profile/#Pro-type-implicitpointercast">묵시적</a>으로 변환될 수 있으면 경고한다</li>
</ul>
<h3 id="es49-named-cast"><a name="Res-casts-named"></a>ES.49: 타입 변환을 사용해야만 한다면, 미리 정의된 방법으로 변환(named cast)하라</h3>
<h5 id="reason_33">Reason</h5>
<p>가독성. 오류 예방.
Named cast들은 C 스타일이나 함수형 형변환보다 더 구체적이며, 컴파일러가 일부 오류를 잡아낼 수 있도록 한다.</p>
<blockquote>
<p>C 스타일 변환: <code>(int) a</code><br />
함수형 변환: <code>int(a)</code></p>
</blockquote>
<p>Named cast의 목록:</p>
<ul>
<li><code>static_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>std::move</code> // <code>move(x)</code>는 <code>x</code>에 대한 r-value 참조를 반환한다</li>
<li><code>std::forward</code> // <code>forward(x)</code>는 <code>x</code>에 대한 r-value 참조를 반환한다</li>
<li><code>gsl::narrow_cast</code> // <code>narrow_cast&lt;T&gt;(x)</code>는 <code>static_cast&lt;T&gt;(x)</code>와 동일하다</li>
<li><code>gsl::narrow</code> // <code>narrow&lt;T&gt;(x)</code>는 <code>static_cast&lt;T&gt;(x)</code>와 동일하며, 만약 <code>static_cast&lt;T&gt;(x) == x</code>가 아니면 예외 <code>narrowing_error</code>를 던진다</li>
</ul>
<h5 id="example_38">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
    <span class="k">class</span> <span class="nc">D</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">D</span><span class="o">&gt;</span> 
    <span class="n">D</span><span class="o">*</span> <span class="n">upcast</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">pb</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">D</span><span class="o">*</span> <span class="n">pd0</span> <span class="o">=</span> <span class="n">pb</span><span class="p">;</span>        <span class="c1">// error: B* 에서 D*로 묵시적 변환할 수 없다</span>
        <span class="n">D</span><span class="o">*</span> <span class="n">pd1</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="p">)</span><span class="n">pb</span><span class="p">;</span>    <span class="c1">// 적법하지만, 어떻게 되겠는가?</span>
        <span class="n">D</span><span class="o">*</span> <span class="n">pd2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>       <span class="c1">// error: D 는 B의 하위 타입이 아니다</span>
        <span class="n">D</span><span class="o">*</span> <span class="n">pd3</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>  <span class="c1">// OK: 정말 괜찮다면!</span>
        <span class="n">D</span><span class="o">*</span> <span class="n">pd4</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>      <span class="c1">// OK: nullptr를 반환한다</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>이 예시는 <code>D</code>가 <code>B</code>의 하위 타입이면서, 누군가 계층 구조를 리팩토링 했을때 발생한 실제 버그들을 종합한 것이다.
C 스타일 타입변환이 위험한 이유는 어떤 형태로의 변환도 수행할 수 있기 때문이다. 이는 실수로부터 우리를 보호해주지 않는다 (지금도, 앞으로도). </p>
<h5 id="note_29">Note</h5>
<p>정보의 손실이 없는 타입 변환의 경우 (가령 <code>float</code>에서 <code>double</code>로, 혹은 <code>int32</code>에서 <code>int64</code>로 변환하는 경우), <code>{}</code> 초기화를 대신 사용할수도 있다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="n">d</span> <span class="p">{</span><span class="n">some_float</span><span class="p">};</span>
    <span class="kt">int64_t</span> <span class="n">i</span> <span class="p">{</span><span class="n">some_int32</span><span class="p">};</span>
</code></pre></div>


<p>이 코드는 타입 변환을 의도했다는 것이 분명히 드러나고 정확도를 잃을 수 있는 변환을 예방한다.
(예를 들자면 이런 코드에서 <code>float</code>를 <code>double</code>로 초기화 하는 것은 컴파일 오류가 된다)</p>
<h5 id="note_30">Note</h5>
<p><code>reinterpret_cast</code>가 필수적일 수 있다. 하지만 본질적으로 타입 안전하지는 않다 (기계 주소를 포인터로 바꾼다던가):</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Device_register</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x800</span><span class="p">);</span>  <span class="c1">// 필연적으로 위험하다</span>
</code></pre></div>


<h5 id="enforcement_33">Enforcement</h5>
<ul>
<li>C스타일, 함수형 형변환이 있다면 지적한다</li>
<li><a href="../Profile/#Pro-type-reinterpretcast">타입 안전성 프로필</a>은 <code>reinterpret_cast</code>를 금지한다</li>
<li><a href="../Profile/#Pro-type-arithmeticcast">타입 안전성 프로필</a>은 <code>static_cast</code>가 산술 타입간 변환에 사용되면 경고한다</li>
</ul>
<h3 id="es50-const"><a name="Res-casts-const"></a>ES.50: <code>const</code>를 제거하지 마라</h3>
<h5 id="reason_34">Reason</h5>
<p><code>const</code>를 거짓말로 만든다. 대상 변수가 정말로 <code>const</code>로 선언되었다면, <code>const</code>를 제거한 결과는 미정의 행동(undefined behavior)이 된다.</p>
<h5 id="example-bad_19">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>   <span class="c1">// BAD</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// silent side effect</span>
    <span class="n">f</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// undefined behavior</span>
</code></pre></div>


<h5 id="example_39">Example</h5>
<p>경우에 따라서는 코드 중복을 피하고자 <code>const_cast</code>에 의존하고 싶을수도 있다.
이때는 두 함수가 구현은 유사하지만 오직 <code>const</code> 부분만 다를 것이다. 예를 들어:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// BAD, duplicates logic</span>
        <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">get_bar</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* complex logic around getting a non-const reference to my_bar */</span>
        <span class="p">}</span>

        <span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">get_bar</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="cm">/* same complex logic around getting a const reference to my_bar */</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Bar</span> <span class="n">my_bar</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>대신, 구현 코드를 공유하도록 하라. 보통의 경우, 비-<code>const</code> 함수에서 <code>const</code> 함수를 호출할 수 있다.
하지만 그 구현에 복잡한 로직이 있다면 여전히 <code>const_cast</code>를 사용하는 다음과 같은 패턴을 쓰게 될 것이다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// not great, non-const calls const version but resorts to const_cast</span>
        <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">get_bar</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">get_bar</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">get_bar</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="cm">/* the complex logic around getting a const reference to my_bar */</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Bar</span> <span class="n">my_bar</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>이 패턴은 정확하게 사용되었을 때는 호출자가 비-<code>const</code> 개체를 통해 호출하기 때문에 안전하지만, 안전성이 검사기의 규칙만큼 자연스럽게 강제되기는 어렵기 때문에 이상적인 코드는 아니다.</p>
<p>이런 패턴 대신, 공통되는 코드는 공통된 보조 함수(helper function)에 배치하라 -- 그리고 <code>const</code>를 타입 추론에서 찾아내도록 템플릿으로 만들어라. 이는 <code>const_cast</code>이 완전히 필요없게 만든다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>                 <span class="c1">// good</span>
              <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">get_bar</span><span class="p">()</span>       <span class="p">{</span> <span class="k">return</span> <span class="n">get_bar_impl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">get_bar</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get_bar_impl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Bar</span> <span class="n">my_bar</span><span class="p">;</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>   <span class="c1">// good, deduces whether T is const or non-const</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">get_bar_impl</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">get_bar</span><span class="p">()){</span> 
            <span class="c1">// the complex logic around getting </span>
            <span class="c1">// a possibly-const reference to my_bar</span>
        <span class="p">}</span>
    <span class="p">};</span>
</code></pre></div>


<h5 id="exception_9">Exception</h5>
<p><code>const</code>-부정확(incorrect)한 함수를 호출할때 <code>const</code>를 제거해야 할수도 있다.
그런 함수는 한 지점에서 inline <code>const</code>-정확한 함수로 감싸서 사용하라.</p>
<h5 id="example_40">Example</h5>
<p>보통 <code>const</code>를 없애버리는 이유는 변경할 수 없는 객체 속에 있는 일시적인 정보를 변경하기 위해서이다.
예를 들면 캐싱값, 임시계산값, 선계산값 등이다.
이런 값은 <code>const_cast</code>를 쓰는 것보다 <code>mutable</code>이나 간접적인 방법을 사용하면 더 쉽게 처리할 수 있다.</p>
<p>비용이 드는 처리를 거쳐서 계산한 결과를 유지하는 것을 고려해보라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="nf">compute</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// x로부터 값을 계산한다; </span>
                        <span class="c1">// 비용이 많이 든다고 가정한다</span>

    <span class="k">class</span> <span class="nc">Cache</span> <span class="p">{</span>   <span class="c1">// int-&gt;int 처리에서 캐시를 구현한 타입</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// x를 위한 값이 있는가?</span>
        <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">);</span>             <span class="c1">// x를 위한 값 y를 만든다</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">get_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// x에 값을 넣는다</span>
            <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Cache</span> <span class="n">cache</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>여기서 <code>get_val()</code>는 논리적으로는 상수이다. 따라서 <code>const</code>멤버로 만들 수 있을 것이다.
이렇게 하려면 여전히 <code>cache</code>를 변경해야 한다. 일부는 그러지 않고 <code>const_cast</code>를 사용한다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>   <span class="c1">// 타입 변환을 사용한 의심스러운 해결방법</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">get_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Cache</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">cache</span><span class="p">).</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>   <span class="c1">// 코드가 지저분하다</span>
            <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Cache</span> <span class="n">cache</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>다행히, 더 나은 해결책이 있다:
<code>cache</code>가 <code>const</code> 개체여도 변경 가능하다고 표기(state)하는 것이다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>   <span class="c1">// 더 나은 해결방법</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">get_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">mutable</span> <span class="n">Cache</span> <span class="n">cache</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>다른 방법은 <code>cache</code>에 대한 포인터를 보관하는 것이다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>   <span class="c1">// OK, 하지만 조금 지저분하다</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">get_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">cache</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cache</span><span class="o">&gt;</span> <span class="n">cache</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>


<p>이 해결책은 굉장히 유연하지만, <code>cache</code>로 가리키는 개체의 명시적인 생성과 소멸을 필요로 한다.
(아마 그 코드는 <code>X</code>의 생성자와 소멸자에 위치할 것이다).</p>
<p>멀티스레드 코드에서 <code>cache</code>에 데이터 경쟁이 발생하면 <code>std::mutex</code>를 사용해 보호해야 한다.</p>
<h5 id="enforcement_34">Enforcement</h5>
<ul>
<li><code>const_cast</code>를 지적한다.</li>
<li>이 규칙은 <a href="../Profile/#Pro-type-constcast">타입 안정성 분석</a>과 관련 있다</li>
</ul>
<h3 id="es55"><a name="Res-range-checking"></a>ES.55: 범위 검사가 필요없게 하라</h3>
<h5 id="reason_35">Reason</h5>
<p>오버플로우가 발생할 소지가 없다 (또한 더 빠르게 실행될 수 있다).</p>
<h5 id="example_41">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span>      <span class="c1">// print all elements of v</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>   <span class="c1">// find x in v</span>
</code></pre></div>


<h5 id="enforcement_35">Enforcement</h5>
<p>명시적인 범위검사를 찾아서 적절한 대안을 제시한다.</p>
<h3 id="es56-stdmove"><a name="Res-move"></a>ES.56: <code>std::move()</code>는 개체를 다른 유효범위로 명시적으로 옮겨야 할때만 사용하라</h3>
<h5 id="reason_36">Reason</h5>
<p>복제를 막고 성능을 향상시키기 위해 복사보다는 이동을 사용한다.</p>
<p>이동 연산은 보통 빈 개체를 남긴다 (<a href="../Class/#Rc-move-semantic">C.64</a>). 이는 기대밖의 결과 혹은 위험으로 이어질 수 있다. 가능하다면 lvalue로부터 이동하는 것을 피하려 해야한다 (lvalue에 나중에 접근할 수도 있다).</p>
<h5 id="notes">Notes</h5>
<p>이동은 옮겨지는 쪽(source)이 rvalue이면 묵시적으로 일어난다 (예컨대, 함수의 결과처럼 <code>return</code>된 값), 그러니 명시적으로 <code>move</code>를 해서 코드를 복잡하게 만들 필요는 없다.
대신, 값을 반환하는 짧은 함수를 작성하고 함수의 반환과 호출자의 반환값을 받는 부분이 자연스럽게 최적화되도록 하라.</p>
<p>일반적으로, 이 문서의 가이드라인을 따르는 것(변수의 유효범위가 불필요하게 커지지 않게 하거나, 값을 반환하는 짧은 함수를 작성하는 것을 포함한다)은 대부분의 명시적인 <code>std::move</code>를 필요없도록 만든다.</p>
<p>명시적으로 <code>move</code>하는 것은 개체를 다른 유효범위로 이동시킬 때 필요하다.
특히 그 개체를 아래 예시처럼 "sink" 함수로 넘기거나 이동 연산들(이동 생성, 이동 대입 연산자, 그리고 swap 연산)을 호출할 때 필요하다.</p>
<h5 id="example-bad_20">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">sink</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>   <span class="c1">// sink 함수가 x의 소유권을 가져간다</span>

    <span class="kt">void</span> <span class="nf">user</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">;</span>
        <span class="c1">// error: lvalue 참조는 rvalue 참조에 바인딩되지 않는다</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="c1">// OK: sink 가 x의 내용을 가져갔으므로, x는 비어있다고 가정한다</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>

        <span class="c1">// ...</span>

        <span class="c1">// probably a mistake</span>
        <span class="n">use</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>


<p>대부분의 경우 <code>std::move()</code>는 <code>&amp;&amp;</code>를 사용하는 매개변수에 실행인자를 넘길때 사용한다.
그리고 그 뒤에는 대상 개체가 이동했다고 가정하며 (<a href="../Class/#Rc-move-semantic">C.64</a>를 함께 보라), 새로운 값을 그 개체에 쓰기 전까지는 상태를 읽어서는 안된다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;supercalifragilisticexpialidocious&quot;</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span> <span class="c1">// ok, 사본(copy)을 사져간다</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="s">&quot;supercalifragilisticexpialidocious&quot;</span><span class="p">);</span>  <span class="c1">// ok</span>

        <span class="c1">// bad, s1의 값을 보존하고자 한다면 실수한 것이다</span>
        <span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>

        <span class="c1">// bad, s1이 변경되었기 때문에 assert는 실패할 것이다.</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="s">&quot;supercalifragilisticexpialidocious&quot;</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example_42">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">sink</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>  <span class="c1">// p의 소유권을 sink()에 전달한다</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="c1">// ...</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w</span><span class="p">));</span>               <span class="c1">// ok, give to sink()</span>
        <span class="c1">// ...</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>    <span class="c1">// Error: unique_ptr는 복사할 수 없도록 세심하게 설계되었다</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="notes_1">Notes</h5>
<p><code>std::move()</code>는 실제로는 <code>&amp;&amp;</code>로 형변환하는 것이다; 단순히 이 함수를 호출하는 것 만으로는 아무것도 이동시키지 않는다. 대신 인자로 전달된 개체를 이동할수 있도록 만든다.
C++ 언어는 함수로부터의 반환처럼 개체를 이동시킬 수 있는 일반적인 경우(common case)들에 대해 이미 알고 있기 때문에, 
추가적으로 <code>std::move()</code>를 사용해서 코드를 복잡하게 만들 필요는 없다.</p>
<p>"그냥 더 효율적이다"라고 들었기 때문에 <code>std::move()</code>를 사용해서는 절대로 안된다.
정보가 없는 "효율성"에 대한 주장은 믿지 마라(???). 이유 없이 코드를 복잡하게 만들지 마라(??).</p>
<h5 id="example-bad_21">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">make_vector</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
        <span class="c1">// ... load result with data</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>       <span class="c1">// bad; just write &quot;return result;&quot;</span>
    <span class="p">}</span>
</code></pre></div>


<p><code>return move(local_variable);</code>와 같은 코드는 절대로 작성하지 마라, 언어차원에서 이미 그 변수가 이동의 대상이 된다는 것을 알고 있다.
코드에 <code>move</code>를 써놓는 것은 도움이 되지 않으며, 지역 변수에 대한 추가적인 참조를 만들어서 일부 컴파일러들의 반환값 최적화(RVO: Return Value Optimization)를 방해(detrimental)한다.</p>
<h5 id="example-bad_22">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// bad; move를 작성하지 않아도 이동 의미구조가 적용된다</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">make_vector</span><span class="p">());</span>
</code></pre></div>


<p><code>f</code>가 값(by value)을 반환한다면, 절대로 <code>x = move(f());</code>처럼 반환되는 값에 <code>move</code>를 사용하지 마라.
언어차원에서 반환 값이 임시 개체이며, 이 개체가 이동할 수 있다는 것을 이미 알고 있다.</p>
<h5 id="example_43">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">mover</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">call_something</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>         <span class="c1">// ok</span>
        <span class="n">call_something</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>   <span class="c1">// bad, don&#39;t std::forward an rvalue reference</span>
        <span class="n">call_something</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// suspicious, why not std::move?</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">forwarder</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">call_something</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>         <span class="c1">// bad, don&#39;t std::move a forwarding reference</span>
        <span class="n">call_something</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>   <span class="c1">// ok</span>
        <span class="n">call_something</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>  <span class="c1">// suspicious, why not std::forward?</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_36">Enforcement</h5>
<ul>
<li><code>x</code>가 rvalue이거나 언어에서 rvalue로 처리할때 <code>std::move(x)</code>가 사용되면 지적한다. <br />
<code>return std::move(local_variable);</code>같은 코드나 값을 반환하는 함수에서 <code>std::move(f())</code>를 포함한다</li>
<li><code>S&amp;&amp;</code> 매개변수를 받는 함수가 lvalue를 처리하기 위한 <code>const S&amp;</code> 중복정의가 없으면 지적한다</li>
<li><code>std::move</code>로 실행인자를 전달하면 지적한다.<br />
  매개변수의 타입이 <code>X&amp;&amp;</code>가 아니거나, 템플릿 매개변수가 <code>T</code>이면서 <code>T&amp;&amp;</code>로 전달하지 않거나, move만 가능한 타입의 값을 받는 경우는 제외한다</li>
<li><code>std::move</code>가 forwarding 참조(<code>T</code>가 템플릿 매개변수 타입일때 <code>T&amp;&amp;</code>를 매개변수로 사용)에 적용되었으면 지적한다. 대신 <code>std::forward</code>를 사용해야 한다. </li>
<li><code>std::move</code>가 rvalue 참조가 아닌 부분에 사용되었으면 지적한다<br />
  (이전 규칙에서 forward하지 않는 경우를 추가한 좀 더 일반화된 규칙이다)</li>
<li><code>std::forward</code>가 rvalue 참조(<code>X</code>가 실제 타입일 때 <code>X&amp;&amp;</code>를 매개변수로 사용)에 사용되었으면 지적한다. 대신 <code>std::move</code>를 사용해야 한다.</li>
<li><code>std::forward</code>가 forwarding 참조 이외에 사용되었으면 지적한다
  (이전 규칙에서 move하지 않는 경우를 추가한 좀 더 일반화된 규칙이다)</li>
<li>Flag when an object is potentially moved from and the next operation is a <code>const</code> operation; there should first be an intervening non-<code>const</code> operation, ideally assignment, to first reset the object's value.</li>
</ul>
<h3 id="es60-new-delete"><a name="Res-new"></a>ES.60: 자원을 관리하는 함수 외부에서 <code>new</code>와 <code>delete</code> 사용을 피하라</h3>
<h5 id="reason_37">Reason</h5>
<p>프로그램 코드 내에서 직접적인 리소스 관리는 에러를 발생시키기 쉬우며 지루(tedious)하다.</p>
<h5 id="note_31">Note</h5>
<p>"<code>new</code>를 노출시켜서 사용하지 마라!"로 알려져있다</p>
<h5 id="example-bad_23">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>   <span class="c1">// n default constructed Xs</span>
        <span class="c1">// ...</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p><code>...</code>에 <code>delete</code>가 발생하지 않게 만드는 코드가 있을 수도 있다.</p>
<h5 id="see-also_1">See also</h5>
<p><a href="../Resource/">R: 리소스 관리</a></p>
<h5 id="enforcement_37">Enforcement</h5>
<p>그대로 노출된 <code>new</code>와 <code>delete</code>를 지적한다.</p>
<h3 id="es61-delete-delete"><a name="Res-del"></a>ES.61: 배열은 <code>delete[]</code>, 단일 개체는 <code>delete</code>를 사용해서 해제하라</h3>
<h5 id="reason_38">Reason</h5>
<p>C++언어가 요구하는 것이며, 리소스 해제 오류와 메모리 오염(memory corruption) 문제가 발생할 수 있다. </p>
<h5 id="example-bad_24">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>   <span class="c1">// n 개의 X를 생성한다</span>
        <span class="c1">// ...</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">// error: p[] 배열이 아니라 p의 대상이 되는 첫번째 개체만 파괴한다, </span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_32">Note</h5>
<p>이 예제는 <a href="#Res-new">no naked <code>new</code> rule</a>를 위반할 뿐만 아니라 많은 다른 문제를 야기한다.</p>
<h5 id="enforcement_38">Enforcement</h5>
<ul>
<li><code>new</code>, <code>delete</code>가 같은 영역범위에 있다면 오류여부를 지적할 수 있다</li>
<li><code>new</code>, <code>delete</code>가 생성자/소멸자 안에 있다면 오류여부를 지적할 수 있다</li>
</ul>
<h3 id="es62"><a name="Res-arr2"></a>ES.62: 서로 다른 배열에 대한 포인터를 비교하지 마라</h3>
<h5 id="reason_39">Reason</h5>
<p>결과가 정의되지 않았다.</p>
<h5 id="example-bad_25">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a1</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">a2</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">a2</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="p">{}</span>       <span class="c1">// bad: undefined</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">a2</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="p">{}</span>   <span class="c1">// bad: undefined</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_33">Note</h5>
<p>더 많은 문제가 내포되어 있다.</p>
<h5 id="enforcement_39">Enforcement</h5>
<p>???</p>
<h3 id="es63-slice"><a name="Res-slice"></a>ES.63: 복사 손실(slice)이 없도록 하라</h3>
<h5 id="reason_40">Reason</h5>
<p>Slicing이란 개체의 일부분만을 사용해서 대입하거나 초기화 하는 것을 의미한다 -- 대부분 개체는 모든 멤버를 가지고 있다고 생각하며 작성되었기에 이는 오류로 이어진다.</p>
<p>드물게도 slicing을 신중하게 사용한다는 것이 놀라울수도 있다.</p>
<h5 id="example_44">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
        <span class="cm">/* ... */</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span> 
        <span class="cm">/* ... */</span> 
        <span class="n">Point</span> <span class="n">c</span><span class="p">;</span> 
        <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Circle</span> <span class="n">c</span> <span class="p">{{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="mi">42</span><span class="p">};</span>
    <span class="n">Shape</span> <span class="n">s</span> <span class="p">{</span><span class="n">c</span><span class="p">};</span>    <span class="c1">// Circle의 Shape부분을 복사한다</span>
</code></pre></div>


<p>복사한 결과는 <code>c</code>의 중심점과 반지름이 <code>s</code>로 복사되지 않았기 때문에 무의미할 것이다. 
이 문제를 막는 방법은 <a href="../Class/#Rc-copy-virtual">상위 클래스 <code>Shape</code>가 이런 동작을 허용하지 않도록 작성하는 것이다</a>.</p>
<h5 id="alternative_1">Alternative</h5>
<p>복사 손실을 의도했다면, 그런 일을 하는 명시적인 처리(operation)를 작성하라.
이렇게 하는것이 코드를 읽는 사람들이 혼란을 겪지 않도록 만든다.</p>
<p>예를 들면:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">class</span> <span class="nc">Smiley</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Circle</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
        <span class="n">Circle</span> <span class="n">copy_circle</span><span class="p">();</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Smiley</span> <span class="n">sm</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
    <span class="n">Circle</span> <span class="n">c1</span> <span class="p">{</span><span class="n">sm</span><span class="p">};</span>  <span class="c1">// 이상적으로는 Circle의 정의에 의해 금지(prevent)되어야 한다.</span>
    <span class="n">Circle</span> <span class="n">c2</span> <span class="p">{</span><span class="n">sm</span><span class="p">.</span><span class="n">copy_circle</span><span class="p">()};</span>
</code></pre></div>


<h5 id="enforcement_40">Enforcement</h5>
<p>복사 손실은 경고하라.</p>
<h3 id="es64-te"><a name="Res-construct"></a>ES.64: 개체를 생성할 때는 <code>T{e}</code>표기를 사용하라</h3>
<h5 id="reason_41">Reason</h5>
<p><code>T{e}</code> 생성 문법은 생성자 호출을 기대한다는 것을 분명하게 드러낸다.
<code>T{e}</code> 생성 문법은 타입의 축소 변환(narrowing)을 허용하지 않는다.
<code>T{e}</code> 는 타입 <code>T</code>의 개체를 표현식 <code>e</code>로부터 생성하는 안전하고 범용적인 유일한 방법이다.
타입 변환을 위한 표기는 <code>T(e)</code>와 <code>(T)e</code>을 사용하고, 둘 중 그 무엇도 안전하거나 범용적이지 않다.</p>
<h5 id="example_45">Example</h5>
<p>언어의 기본(built-in) 타입들에 대해서는, 이 표기법을 사용한 생성은 축소 변환과 재해석(reinterpretation)을 예방한다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lng</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="kt">int</span><span class="p">{</span><span class="n">ch</span><span class="p">};</span>     <span class="c1">// OK, but redundant</span>
        <span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="kt">int</span><span class="p">{</span><span class="n">d</span><span class="p">};</span>      <span class="c1">// error: double-&gt;int narrowing; use a cast if you need to</span>
        <span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="kt">int</span><span class="p">{</span><span class="n">p</span><span class="p">};</span>      <span class="c1">// error: pointer to-&gt;int; use a reinterpret_cast if you really need to</span>
        <span class="kt">int</span> <span class="n">x4</span> <span class="o">=</span> <span class="kt">int</span><span class="p">{</span><span class="n">lng</span><span class="p">};</span>    <span class="c1">// error: long long-&gt;int narrowing; use a cast if you need to</span>

        <span class="kt">int</span> <span class="n">y1</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>     <span class="c1">// OK, but redundant</span>
        <span class="kt">int</span> <span class="n">y2</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>      <span class="c1">// bad: double-&gt;int narrowing; use a cast if you need to</span>
        <span class="kt">int</span> <span class="n">y3</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>      <span class="c1">// bad: pointer to-&gt;int; use a reinterpret_cast if you really need to</span>
        <span class="kt">int</span> <span class="n">y4</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">lng</span><span class="p">);</span>    <span class="c1">// bad: long long-&gt;int narrowing; use a cast if you need to</span>

        <span class="kt">int</span> <span class="n">z1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ch</span><span class="p">;</span>     <span class="c1">// OK, but redundant</span>
        <span class="kt">int</span> <span class="n">z2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>      <span class="c1">// bad: double-&gt;int narrowing; use a cast if you need to</span>
        <span class="kt">int</span> <span class="n">z3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>      <span class="c1">// bad: pointer to-&gt;int; use a reinterpret_cast if you really need to</span>
        <span class="kt">int</span> <span class="n">z4</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lng</span><span class="p">;</span>    <span class="c1">// bad: long long-&gt;int narrowing; use a cast if you need to</span>
    <span class="p">}</span>
</code></pre></div>


<p>정수와 포인터 사이의 변환에 <code>T(e)</code>혹은 <code>(T)e</code>표기를 사용하면 구현에따라 달라질 수 있기 때문에, 
정수와 포인터의 크기가 다른 플랫폼에서는 쓸수 없는(non-portable) 코드가 된다</p>
<h5 id="note_34">Note</h5>
<p><a href="#Res-casts">타입 변환을 피하라</a> (명시적 타입 변환) 그리고 가능하다면 <a href="#Res-casts-named">named cast를 사용하라</a>.</p>
<h5 id="note_35">Note</h5>
<p>모호하다면, <code>T{e}</code>표기에서 <code>T</code>를 지워버리고 표현식만 남길수도 있다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span>
</code></pre></div>


<h5 id="note_36">Note</h5>
<p>개체 생성 표기법은 가장 범용적인 <a href="#Res-list">초기화 표기법이다</a>.</p>
<h5 id="exception_10">Exception</h5>
<p><code>std::vector</code>와 다른 컨테이너들은 <code>{}</code>를 생성자를 위한 표기로 사용하기 전에 설계되었다.
다음과 같은 코드를 고려해보라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vs</span> <span class="p">{</span><span class="mi">10</span><span class="p">};</span>                           <span class="c1">// ten empty strings</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi1</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>  <span class="c1">// ten elements 1..10</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi2</span> <span class="p">{</span><span class="mi">10</span><span class="p">};</span>                             <span class="c1">// one element with the value 10</span>
</code></pre></div>


<p>어떻게 하면 <code>vector</code>가 10개의 기본 초기화된 <code>int</code>를 가지도록 할 수 있을까?</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// ten elements with value 0</span>
</code></pre></div>


<p>원소의 수를 생성자에 전달하기 위해 <code>{}</code>대신 <code>()</code>를 사용하는 것은 전통적인 코드를 따른 것이다 (1980년대 초반으로 거슬러 올라간다). 
이는 바꾸기 어렵지만, 설계 오류라는 것은 여전하다: for a container where the element type can be confused with the number of elements, we have an ambiguity that must be resolved.
전통적인 코드를 따라서 <code>{10}</code>를 해석하면 하나의 원소로 만들어진 리스트이고, <code>(10)</code>는 컨테이너의 크기를 의미한다.</p>
<p>새로운 코드에서 이런 실수가 반복되어선 안된다.
원소의 개수를 표현하는 타입을 정의하는 것도 가능하다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">struct</span> <span class="n">Count</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Vector</span><span class="p">(</span><span class="n">Count</span> <span class="n">n</span><span class="p">);</span>                     <span class="c1">// n default-initialized elements</span>
        <span class="n">Vector</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">init</span><span class="p">);</span>    <span class="c1">// init.size() elements</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>
    <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="n">Count</span><span class="p">{</span><span class="mi">10</span><span class="p">}};</span>
    <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Count</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">{</span><span class="n">Count</span><span class="p">{</span><span class="mi">10</span><span class="p">}};</span>    <span class="c1">// yes, there is still a very minor problem</span>
</code></pre></div>


<p>남은 문제는 <code>Count</code>에 알맞는 이름을 찾는 것이다.</p>
<h5 id="enforcement_41">Enforcement</h5>
<p>C 스타일 <code>(T)e</code>변환과 함수형 타입변환 <code>T(e)</code>를 지적한다</p>
<h3 id="es65-invalid"><a name="Res-deref"></a>ES.65: 유효하지 않은(invalid) 포인터를 역참조하지 마라</h3>
<h5 id="reason_42">Reason</h5>
<p><code>nullptr</code>처럼 유효하지 않은 포인터를 역참조하는 것은 미정의 행동이다. 일반적으로 역참조하는 그 즉시 크래시가 발생하거나, 잘못된 결과, 혹은 메모리 파괴(corruption)가 일어난다.</p>
<h5 id="note_37">Note</h5>
<p>이 규칙은 명백하고 잘 알려진 언어 규칙이지만, 따르기 어렵다.
큰 부담(overhead)없이 이 규칙을 준수하기 위해서는 좋은 코딩스타일, 라이브러리 지원, 그리고 정적 분석기가 필요하다.
<a href="../Bibliography/#Stroustrup15">C++'s resource- and type-safety model</a> 논의에서의 중요 부분 중 하나다.</p>
<h5 id="see-also_2">See also</h5>
<ul>
<li>수명주기 문제를 피하려면 <a href="#Rr-raii">RAII</a>를 사용하라</li>
<li>수명주기 문제를 피하려면 <a href="#Rf-unique_ptr">unique_ptr</a>를 사용하라</li>
<li>수명주기 문제를 피하려면 <a href="#Rf-shared_ptr">shared_ptr</a>를 사용하라</li>
<li><code>nullptr</code>가 허용되지 않는다면 <a href="#Rf-ptr-ref">references</a>를 사용하라</li>
<li>의도치 않은 <code>nullptr</code>를 일찍 잡아내기 위해 <a href="#Rf-not_null">not_null</a>을 사용하라</li>
<li>범위 오류를 피하고 싶다면 <a href="../Profile/#SS-bounds">경계 안전성 프로필</a>을 참고하라</li>
</ul>
<h5 id="example_46">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
        <span class="p">}</span> <span class="c1">// invalidates p</span>

        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>            <span class="c1">// BAD, p는 분기문을 거쳤다면 유효하지 않은 값을 가지고 있다</span>
    <span class="p">}</span>
</code></pre></div>


<p>이런 문제를 해결하기 위해, 참조되는 개체의 수명을 늘리거나, 참조하는 포인터의 수명을 줄이는 방법이 있다. (역참조하는 시점을 참조되는 개체의 수명이 끝나기 전으로 앞당긴다)</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>            <span class="c1">// OK, p points to x or y and both are still in scope</span>
    <span class="p">}</span>
</code></pre></div>


<p>불행하게도, 대부분의 유효하지 않은 포인터 문제는 찾아내기도, 고치기도 어렵다.</p>
<h5 id="example_47">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// BAD: how do we know that p is valid?</span>
    <span class="p">}</span>
</code></pre></div>


<p>이런 코드가 엄청나게 많이 있다.</p>
<p>대부분 제대로 동작하지만 -- 수많은 테스트를 거친 후에야 -- 저 코드만 놓고 보면 <code>p</code>가 <code>nullptr</code>가 될 수 있는지에 대해 확답할 수 없다.
결과적으로는 이 역시 오류의 주요 원인이다.
이런 잠재적인 문제를 다루기 위해 많은 시도가 있었다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="c1">// nullptr를 처리해보자</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// nullptr인 경우 새로 할당하거나, 반환하거나, </span>
            <span class="c1">//  예외를 던지거나, 다른 무언가를 가리키게 하거나...</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p><code>nullptr</code>를 검사하는데는 두가지 잠재적 문제가 있다:</p>
<ul>
<li>매번 <code>nullptr</code>를 찾은 후에 무엇을 해야하는지 분명한 것은 아니다</li>
<li>테스트가 중복적이거나 상대적으로 비용이 많이 들수도 있다</li>
<li>테스트의 목적이 잘못된 메모리 참조(violation)를 막기 위한 것인지 로직을 보호하기 위한 것인지 불분명하다</li>
</ul>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="c1">// state that p is not supposed to be nullptr</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>위 방법은 단정문(assertion)이 활성화될 때만 비용이 발생하고 컴파일러, 분석기에 유용한 정보를 제공할 것이다. 
C++이 Contract를 지원하게 되면 좀 더 나은 코드가 될 것이다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="c1">// state that p is not supposed to be nullptr</span>
        <span class="p">[[</span><span class="nl">expects</span><span class="p">:</span> <span class="n">p</span><span class="p">]]</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>다른 방법으로는, <code>p</code>가 <code>nullptr</code>가 되지 않는다는 것을 분명히 하기위해 <code>gsl::not_null</code>를 사용할수도 있다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">not_null</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>이런 방편들은 <code>nullptr</code>인 경우 만을 다룬다.
유효하지 않은 포인터가 <code>nullptr</code>가 아닌 경우도 있다는 것을 기억하라.</p>
<h5 id="example_48">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>  <span class="c1">// old code, doesn&#39;t use owner</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>        <span class="c1">// old code: uses naked new</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">};</span>
        <span class="n">f</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span> <span class="c1">// BAD: dereferences invalid pointer</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example_49">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">99</span><span class="p">);</span> <span class="c1">// could reallocate v&#39;s elements</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// BAD: dereferences potentially invalid pointer</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_42">Enforcement</h5>
<p>이 규칙은 <a href="../Profile/#SS-lifetime">수명주기 안전성 분석</a>의 일부분이다.</p>
<ul>
<li>포인터가 유효범위를 벗어난 개체를 가리키고 있다면 지적하라</li>
<li>포인터가 <code>nullptr</code>를 대입해서 유효하지 않게 되었다면 지적하라 </li>
<li>포인터가 <code>delete</code>에 의해서 유효하지 않게 되었을 수 있으면 지적하라</li>
<li>포인터가 사라졌을 수 있는 컨테이너의 원소를 가리키고 있으면 지적하라</li>
</ul>
<h2 id="esstmt-statement">ES.stmt: 구문(statement)</h2>
<p>구문은 제어 흐름(the flow of control)을 통제(control)한다.
(함수 호출과 예외를 던지는 것은 표현식이다)</p>
<h3 id="es70-if-switch"><a name="Res-switch-if"></a>ES.70: 선택을 하는 경우에는 <code>if</code>구문보다는 <code>switch</code>구문을 사용하라</h3>
<h5 id="reason_43">Reason</h5>
<ul>
<li>가독성</li>
<li>효율성: 상수값에 대해서 비교를 수행하므로 <code>if</code>-<code>then</code>-<code>else</code>문의 연속보다 <code>switch</code>문이 더 잘 최적화될 수 있다.</li>
<li><code>switch</code> 문은 경험적인 형태의 일관성 검사를 할 수 있게 한다.<br />
  예를 들자면, <code>enum</code> 모든 값을 확인하고 있는가? 그렇지 않다면 <code>default</code>는 있는가?</li>
</ul>
<h5 id="example_50">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// good</span>
        <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
            <span class="c1">// ...</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">7</span><span class="o">:</span>
            <span class="c1">// ...</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="c1">// ...</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<p>위의 예제가 더 좋다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">use2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">// bad: if-then-else 가 반복되면서 상수들과 비교를 수행한다</span>
            <span class="c1">// ...</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
            <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_43">Enforcement</h5>
<p>상수값에 대해서 비교하는 if-then-else가 연속되면 지적한다. (이 경우에만)</p>
<h3 id="es71-for-for-"><a name="Res-for-range"></a>ES.71: 가능하다면 일반 <code>for</code>구문 보다 범위기반 <code>for</code>-구문을 사용하라</h3>
<h5 id="reason_44">Reason</h5>
<p>가독성. 오류 예방. 효율성.</p>
<h5 id="example_51">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>   <span class="c1">// bad</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>   <span class="c1">// bad</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span>    <span class="c1">// OK</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// touches two elements: can&#39;t be a range-for</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// possible side effect: can&#39;t be a range-for</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// body messes with loop variable: can&#39;t be a range-for</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>   <span class="c1">// skip even elements</span>
        <span class="k">else</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>프로그래머나 좋은 정적 분석기는 <code>f(&amp;v[i])</code>에서 <code>v</code>에 대해서 부수효과(side effect)가 일어나지 않는다고 판단할지도 모른다. 이 경우 루프를 최적화할 수 있다.</p>
<p>루프문 내에서 "루프변수를 변경"하는 경우가 없어야 한다.</p>
<h5 id="note_38">Note</h5>
<p>범위 기반 <code>for</code>문에서 루프변수를 복사하여 사용하지 마라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">vs</span><span class="p">)</span>
        <span class="c1">// ...</span>
</code></pre></div>


<p>위 코드는 <code>vs</code>의 원소를 <code>s</code>로 복사한다. 개선하면:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">vs</span><span class="p">)</span>
        <span class="c1">// ...</span>
</code></pre></div>


<p>만약 루프 변수(<code>s</code>)가 변경되거나 복사되지 않는다면 이렇게 작성하라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">vs</span><span class="p">)</span>
        <span class="c1">// ...</span>
</code></pre></div>


<h5 id="enforcement_44">Enforcement</h5>
<p>루프를 보고 개별 요소들을 일렬로 참조하고 있고 부수효과(side effect)가 없어 보이면 <code>for</code>문으로 재작성한다.</p>
<h3 id="es72-while-for-"><a name="Res-for-while"></a>ES.72: 루프 변수가 있다면 <code>while</code>-구문보다 <code>for</code>-구문을 사용하라</h3>
<h5 id="reason_45">Reason</h5>
<p>가독성: 루프에 대한 전체 로직을 첫구문에서 볼 수 있다. 
루프변수의 범위가 제한되는 점도 좋다.</p>
<h5 id="example_52">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// do work</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-bad_26">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// do work</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_45">Enforcement</h5>
<p>???</p>
<h3 id="es73-for-while-"><a name="Res-while-for"></a>ES.73: 루프 변수가 없다면 <code>for</code>-구문보다 <code>while</code>-구문을 사용하라</h3>
<h5 id="reason_46">Reason</h5>
<p>가독성</p>
<h5 id="example_53">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">wait_for_event</span><span class="p">();</span> <span class="o">++</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// bad, 혼란스럽다</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>이 "이벤트 루프"는 잘못된 코드인데, <code>events</code> 카운터 변수가 반복 조건에 전혀 영향을 주지 않기 때문이다 (<code>wait_for_event()</code>). </p>
<p>이런 코드가 더 좋다</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">wait_for_event</span><span class="p">())</span> <span class="p">{</span>      <span class="c1">// better</span>
        <span class="o">++</span><span class="n">events</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_46">Enforcement</h5>
<p>Flag actions in <code>for</code>-initializers and <code>for</code>-increments that do not relate to the <code>for</code>-condition.</p>
<h3 id="es74-for-"><a name="Res-for-init"></a>ES.74: 루프 변수는 <code>for</code>-구문의 초기화 부분에서 선언하라</h3>
<h5 id="reason_47">Reason</h5>
<p>루프 변수의 가시범위를 루프 범위 내로 제한하라.
루프문 뒤에서 다른 목적으로 루프 변수를 사용하지 못하게 하라.</p>
<h5 id="example_54">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// GOOD: i var is visible only inside the loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-dont">Example, don't</h5>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// BAD: j is visible outside the loop</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="c1">// j is still visible here and isn&#39;t needed</span>
</code></pre></div>


<h5 id="see-also_3">See also</h5>
<p><a href="#Res-recycle">Don't use a variable for two unrelated purposes</a></p>
<h5 id="example_55">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_47">Enforcement</h5>
<p><code>for</code>문 안에서만 변하는 변수가 루프 밖에 선언되어 있지만 루프 밖에서 사용되지 않고 있다면 경고한다.</p>
<h5 id="discussion">Discussion</h5>
<p>루프 변수를 루프 구문의 범위에 두면 코드 최적화에 많은 도움이 된다.
귀납 변수(induction variable)가 루프구문 안에서만 접근가능함을 파악하면 
위치이동(hoisting), 연산 부담 완화(strength reduction), 루프 내 불변코드 이동(loop-invariant code motion) 등의 최적화가 가능해진다.</p>
<blockquote>
<p>번역 참고:
* https://en.wikipedia.org/wiki/Strength_reduction
* https://code-examples.net/ko/docs/gcc~7/optimize-options</p>
</blockquote>
<h3 id="es75-do-"><a name="Res-do"></a>ES.75: <code>do</code>-구문을 사용하지 마라</h3>
<h5 id="reason_48">Reason</h5>
<p>가독성. 오류 회피.
종료 조건이 끝에 위치해 있고(못 보고 넘어가기 쉬운 위치) 첫 루프에서 조건을 검사하지 않는다.</p>
<h5 id="example_56">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<h5 id="note_39">Note</h5>
<p>물론 <code>do</code>-구문이 깔끔한 해결방법이 되는 예시도 존재한다. 하지만 동시에 많은 버그를 발생시키기도 한다.</p>
<h5 id="enforcement_48">Enforcement</h5>
<p><code>do</code>-구문이 있으면 지적한다</p>
<h3 id="es76-goto"><a name="Res-goto"></a>ES.76: <code>goto</code>를 사용하지 마라</h3>
<h5 id="reason_49">Reason</h5>
<p>가독성. 오류 회피. 사람을 위해서는 더 좋은 컨트롤 구조가 있다;
<code>goto</code>는 기계코드(machine generated code)를 위한 것이다.</p>
<h5 id="exception_11">Exception</h5>
<p>중첩된 루프에서 탈출.
이런 경우라면 항상 처리의 진행방향(forward)으로 점프하라.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imax</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">jmax</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">elem_max</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="nl">finished</span><span class="p">:</span>
    <span class="c1">// ...</span>
</code></pre></div>


<h5 id="example-bad_27">Example, bad</h5>
<p>C 에서는 goto-exit 형태(idiom)를 꽤 많이 사용한다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
            <span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
        <span class="c1">// ...</span>
            <span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="nl">exit</span><span class="p">:</span>
        <span class="c1">// ... common cleanup code ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>이건 소멸자를 시뮬레이션한 것이다. 리소스를 해제하는 소멸자를 가진 핸들로 선언하라.</p>
<p>사용된 변수들의 소멸자로 모든 정리 작업(cleanup)을 다룰 수 없다면, 
소멸 작업을 <code>goto exit</code> 대신 더 신뢰할 수 있는 <code>gsl::finally()</code>로 처리하는 것을 고려하라</p>
<h5 id="enforcement_49">Enforcement</h5>
<ul>
<li><code>goto</code>가 보이면 지적한다. 루프 다음문으로 점프하지 않는 중첩 루프 내의 <code>goto</code>는 모두 표시하면 더 좋다.</li>
</ul>
<h3 id="es77-break-continue"><a name="Res-continue"></a>ES.77: <code>break</code>와 <code>continue</code>의 사용을 최소화하라</h3>
<h5 id="reason_50">Reason</h5>
<p>간단하지 않은(non-trivial) 반복문 내에서는 <code>break</code>혹은 <code>continue</code>를 간과하기 쉽다.</p>
<p>반복문에서 <code>break</code>는 <code>switch</code> 구문 내에서와는 완전히 다른 의미를 가진다. (그리고 <code>switch</code>구문 내에서 반복문을 사용하거나 반복문 안에서 <code>switch</code>를 사용하는것이 가능하다).</p>
<h5 id="example_57">Example</h5>
<div class="codehilite"><pre><span></span><code>    ???
</code></pre></div>


<h5 id="alternative_2">Alternative</h5>
<p>때때로, <code>break</code>를 필요로 하는 반복문은 함수(알고리즘)의 후보가 되기도 한다. 이 경우 <code>break</code>는 그 함수의 <code>return</code>이 된다.</p>
<div class="codehilite"><pre><span></span><code>    ???
</code></pre></div>


<p>경우에 따라서는 <code>continue</code>를 사용하는 반복문은 <code>if</code> 구문을 사용해 논리적으로 동일하게 표현할 수 있다.</p>
<div class="codehilite"><pre><span></span><code>    ???
</code></pre></div>


<h5 id="note_40">Note</h5>
<p>정말로 반복문 중간에서 탈출해야 한다면, <code>break</code>는 보통 <a href="#Res-loop-counter">루프 변수를 조작</a>하거나 <a href="#Res-goto"><code>goto</code></a>를 쓰는 방법보다 더 나은 방법이다.</p>
<h5 id="enforcement_50">Enforcement</h5>
<p>???</p>
<h3 id="es78-case-break"><a name="Res-break"></a>ES.78: 내용이 있는 <code>case</code>는 <code>break</code>하라</h3>
<h5 id="reason_51">Reason</h5>
<p>실수로 <code>break</code>를 붙이지 않는 것은 꽤 많이 발생하는 버그다.
고의적으로 <code>break</code>를 없애는 것(fallthrough)은 유지보수의 위험요소가 된다.</p>
<h5 id="example_58">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">switch</span> <span class="p">(</span><span class="n">eventType</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">Information</span><span class="p">:</span>
        <span class="n">update_status_bar</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Warning</span><span class="p">:</span>
        <span class="n">write_event_log</span><span class="p">();</span>
        <span class="c1">// Bad - implicit fallthrough</span>
    <span class="k">case</span> <span class="nl">Error</span><span class="p">:</span>
        <span class="n">display_error_window</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p><code>break</code>로 안 끝나는 사항은 간과하기 쉽다. 명확하게 하라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">switch</span> <span class="p">(</span><span class="n">eventType</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">Information</span><span class="p">:</span>
        <span class="n">update_status_bar</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Warning</span><span class="p">:</span>
        <span class="n">write_event_log</span><span class="p">();</span>
        <span class="c1">// fallthrough</span>
    <span class="k">case</span> <span class="nl">Error</span><span class="p">:</span>
        <span class="n">display_error_window</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>C++17에서는, <code>[[fallthrough]]</code>를 사용하라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">switch</span> <span class="p">(</span><span class="n">eventType</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">Information</span><span class="p">:</span>
        <span class="n">update_status_bar</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Warning</span><span class="p">:</span>
        <span class="n">write_event_log</span><span class="p">();</span>
        <span class="p">[[</span><span class="n">fallthrough</span><span class="p">]];</span>        <span class="c1">// C++17</span>
    <span class="k">case</span> <span class="nl">Error</span><span class="p">:</span>
        <span class="n">display_error_window</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="note_41">Note</h5>
<p>단일문으로 모이는 여러개의 케이스 조건은 허용된다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;a&#39;</span><span class="o">:</span>
    <span class="k">case</span> <span class="sc">&#39;b&#39;</span><span class="o">:</span>
    <span class="k">case</span> <span class="sc">&#39;f&#39;</span><span class="o">:</span>
        <span class="n">do_something</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_51">Enforcement</h5>
<p>빈 <code>case</code>문이 아닌데 break로 끝나지 않는다면 지적한다.</p>
<h3 id="es79-default"><a name="Res-default"></a>ES.79: (오직) 일반적인 경우를 처리하기 위해서 <code>default</code>를 사용하라</h3>
<h5 id="reason_52">Reason</h5>
<p>코드의 명확성.
오류를 탐지할 기회를 늘려준다.</p>
<h5 id="example_59">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">enum</span> <span class="n">E</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="p">,</span> <span class="n">d</span> <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">E</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">a</span><span class="p">:</span>
            <span class="n">do_something</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">b</span><span class="p">:</span>
            <span class="n">do_something_else</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">take_the_default_action</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<p>이 예시에는 기본 행동과 <code>a</code>와 <code>b</code>라는 특별한 경우를 처리한다는 것이 분명하게 나타난다.</p>
<h5 id="example_60">Example</h5>
<p>기본 행동 없이 특별한 경우만 처리하려고 의도했다면 어떨까?
그런 경우라면, 내용 없는 <code>default</code>를 두지 않으면 당신이 모든 경우를 다루도록 의도했다는 것을 알 수 없다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">E</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">a</span><span class="p">:</span>
            <span class="n">do_something</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">b</span><span class="p">:</span>
            <span class="n">do_something_else</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="c1">// 나머지 경우에는 아무것도 하지 않는다</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<p><code>default</code>를 넣지 않았다면, 그 코드를 유지보수 하는 사람 혹은 컴파일러는 당신이 당연히(reasonably) 모든 경우를 도려했다고 가정할 것이다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">enum</span> <span class="n">E</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="p">,</span> <span class="n">d</span> <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">E</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">a</span><span class="p">:</span>
            <span class="n">do_something</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">b</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">c</span><span class="p">:</span>
            <span class="n">do_something_else</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>


<p><code>d</code>를 처리하는 것을 깜빡한 것일까? 아니면 의도적으로 제외한 것일까?
특정한 경우가 누락되는 것은 보통 열거형의 값이 추가되면서 사람이 모든 <code>switch</code>를 갱신하지 않았을 때 발생한다.</p>
<h5 id="enforcement_52">Enforcement</h5>
<p>열거형을 검사하는 <code>switch</code>-구문에서 <code>default</code>가 없으면서 모든 열거값을 처리하지 않으면 지적하라.
이는 너무 많은 False Positive를 낳을수도 있다; 그런 경우에는, 대부분의 값을 다루지만 모든 값을 검사하지 않는 <code>switch</code>만을 지적하라 (이는 초창기 C++ 컴파일러가 사용한 전략이다).</p>
<h3 id="es84"><a name="Res-noname"></a>ES.84: 이름이 없는 지역변수는 선언(하려고)하지 마라</h3>
<h5 id="reason_53">Reason</h5>
<p>이름 없는 지역변수는 만들 수 없다.
사람에게 이름이 없는 것처럼 보이는 변수는 컴파일러에게는 유효범위에서 바로 사라지는 임시 변수를 포함한 구문이다.
불쾌한 이상행동(unpleasant surprise)이 일어나지 않게 한다.</p>
<h5 id="example-bad_28">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">{</span><span class="n">mx</span><span class="p">};</span>   <span class="c1">// Bad</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>이 구문은 이름 없는 <code>lock</code>개체를 선언하고 세미콜론 이후 즉시 사라지도록 한 것이다.</p>
<p>이는 흔치 않은 실수가 아니다. 특히, 이 예시는 찾기 어려운 경쟁 조건으로 이어질수도 있다.
이 "관용법(idiom)"을 매우 영리하게 사용하는 경우도 있지만, 그런 경우들은 실수와는 거리가 멀다.</p>
<h5 id="note_42">Note</h5>
<p>함수의 실행인자가 이름이 없는 것은 괜찮다.</p>
<h5 id="enforcement_53">Enforcement</h5>
<p>임시변수를 생성하기만 하는 구문을 지적하라.</p>
<h3 id="es85"><a name="Res-empty"></a>ES.85: 비어있는 구문은 눈에띄게 하라</h3>
<h5 id="reason_54">Reason</h5>
<p>가독성.</p>
<h5 id="example_61">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span>   <span class="c1">// BAD: 비어있는 구문의 존재를 못볼 수 있다</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>           <span class="c1">// 좀 더 낫다</span>
        <span class="c1">// nothing</span>
    <span class="p">}</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</code></pre></div>


<h5 id="enforcement_54">Enforcement</h5>
<p>블록이 아니면서 주석문을 포함하지 않는 빈 문장이 있다면 지적한다.</p>
<h3 id="es86-for-body"><a name="Res-loop-counter"></a>ES.86: for 반복문(body) 안에서 루프 변수를 변경하지 마라</h3>
<h5 id="reason_55">Reason</h5>
<p>루프를 제어하는 변수는 반복문 내에서 어떤 일이 일어나는지 정확히 추론할 수 있도록 해야 한다.
루프 카운터를 반복문 안쪽(body)이나 반복 표현식(iteration-expression)에서 변경하는 것은 늘 있는(perennial) 이상행동과 버그의 원인이다.</p>
<h5 id="example_62">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// no updates to i -- ok</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//</span>
        <span class="k">if</span> <span class="p">(</span><span class="cm">/* something */</span><span class="p">)</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="c1">// BAD</span>
        <span class="c1">//</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">skip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span> <span class="n">skip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">//</span>
        <span class="k">if</span> <span class="p">(</span><span class="cm">/* something */</span><span class="p">)</span> <span class="n">skip</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Better: 두 개의 의미(concept)를 위해 두개의 변수를 사용한다.</span>
        <span class="c1">//</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="enforcement_55">Enforcement</h5>
<p>루프 제어의 반복 표현식이나 반복문 안에서 잠재적으로 변수를 갱신하면 (비-<code>const</code> 형태로 사용하면) 지적하라</p>
<h3 id="es87"><a name="Res-if"></a>ES.87: 조건에 불필요한 <code>==</code>나 <code>!=</code>를 사용하지 마라</h3>
<h5 id="reason_56">Reason</h5>
<p>코드를 장황하게 만드는 것을 예방하고 실수가 발생할 여지가 없도록 한다.
코딩 스타일의 일관성이나 관습화를 돕는다.</p>
<h5 id="example_63">Example</h5>
<p>그 정의대로, <code>if</code>-구문, <code>while</code>-구문, 혹은 <code>for</code>-구문에서 사용되는 조건은 <code>true</code>와 <code>false</code>사이에서 선택하는 것을 말한다.
숫자는 <code>0</code>과 비교되고 포인터는 <code>nullptr</code>과 비교한다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// These all mean &quot;if `p` is not `nullptr`&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>            <span class="c1">// good</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>       <span class="c1">// redundant `!=0`; bad: don&#39;t use 0 for pointers</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// redundant `!=nullptr`, not recommended</span>
</code></pre></div>


<p><code>if (p)</code>가 "만약 <code>p</code>가 유효하다면"이라는 프로그래머의 의도를 그대로 반영한 의미로 읽히는 반면에, <code>if (p != nullptr)</code>는 더 많은 말(long-winded workaround)이 필요할 수 있다.</p>
<h5 id="example_64">Example</h5>
<p>이 규칙은 조건문에서 선언이 사용되는 경우 특히 유용하다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pc</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// execute is ps points to a kind of Circle, good</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pc</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span> <span class="n">pc</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// not recommended</span>
</code></pre></div>


<h5 id="example_65">Example</h5>
<p>조건문에서는 bool 타입으로의 암묵적 형변환이 발생한다는 점에 유의하라.
예를 들어:</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="p">)</span> 
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</code></pre></div>


<p>이 코드는 <code>istream</code>의 <code>operator bool()</code>을 호출한다.</p>
<h5 id="note_43">Note</h5>
<p>정수를 <code>0</code>과 명시적으로 비교하는 것은 일반적으로 볼 수 있고, 중복적(redundant)이지는 않다.
그 이유는 (포인터나 불리언과는 반대로) 정수는 때로는 2개 이상의 정당한(reasonable) 값을 가지기 때문이다.
더욱이 <code>0</code> (zero)는 종종 성공을 의미하는데 사용되기도 한다.
결과적으로, 명시적으로 비교하는 것이 최선이다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>            <span class="c1">// 좀 의심스럽다</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">success</span><span class="p">)</span> <span class="c1">// 아마도 더 나은 코드</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</code></pre></div>


<p>정수가 2개 이상의 값을 가진다는 점을 항상 기억하라.</p>
<h5 id="example-bad_29">Example, bad</h5>
<p>알려진 코드 중 이런게 있다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>   <span class="c1">// 두 C-스타일 문자열들이 같은가? (mistake!)</span>
</code></pre></div>


<p>흔히 볼 수 있는 초심자 오류다.
C 스타일 문자열을 사용한다면 <code>&lt;cstring&gt;</code>의 함수들을 잘 알아야 한다.</p>
<p>장황하게 아래처럼 작성하는 것은</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>   <span class="c1">// 두 C-스타일 문자열들이 같은가? (mistake!)</span>
</code></pre></div>


<p>당신을 구해주지 않는다.</p>
<h5 id="note_44">Note</h5>
<p>반대 조건은 부정(negation)을 사용해 쉽게 표현할 수 있다:</p>
<div class="codehilite"><pre><span></span><code>    <span class="c1">// These all mean &quot;if `p` is `nullptr`&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>           <span class="c1">// good</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>       <span class="c1">// redundant `== 0`; bad: don&#39;t use `0` for pointers</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// redundant `== nullptr`, not recommended</span>
</code></pre></div>


<h5 id="enforcement_56">Enforcement</h5>
<p>쉽다, 조건문에서 <code>!=</code>와 <code>==</code>이 중복적으로 사용되는지 검사한다.</p>
<h2 id="arithmetic"><a name="SS-numbers"></a>산술연산(Arithmetic)</h2>
<h3 id="es100"><a name="Res-mix"></a>ES.100: 부호가 있는 타입과 없는 타입을 함께 연산하지 마라</h3>
<h5 id="reason_57">Reason</h5>
<p>결과가 잘못될 수 있다.</p>
<h5 id="example_66">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>  <span class="c1">// unsigned result, possibly 4294967286</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>  <span class="c1">// unsigned result: 4</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>  <span class="c1">// unsigned result, possibly 4294967275</span>
</code></pre></div>


<p>실제 코드에서는 문제를 찾아내기 어렵다.</p>
<h5 id="note_45">Note</h5>
<p>불행히도 C++은 배열인자에 대해서 부호있는 정수를 사용하고 표준 라이브러리는 컨테이너 인자에 부호없는 정수형을 사용한다.</p>
<p>이는 일관적이지 않다. 배열 접근이라면 <code>gsl::index</code>를 사용하라. <a href="#Res-subscripts">ES.107</a>을 참고하라.</p>
<h5 id="enforcement_57">Enforcement</h5>
<ul>
<li>컴파일러가 이미 알고 있는 상황이고 경고할 것이다</li>
<li>(너무 많은 경고를 막기 위해) 비교의 피연산자 중 하나가 <code>sizeof</code> 혹은 컨테이너의 <code>.size()</code>를 사용하고, 다른 한쪽은 <code>ptrdiff_t</code> 경우는 지적하지 마라</li>
</ul>
<h3 id="es101-unsigned"><a name="Res-unsigned"></a>ES.101: 비트 조작시에는 부호가 없는(unsigned) 타입을 사용하라</h3>
<h5 id="reason_58">Reason</h5>
<p>부호없는 타입은 부호비트까지 포함해서 비트 연산할 수 있도록 지원하기 때문에 의도한 대로 동작한다.</p>
<h5 id="example_67">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b1010</span><span class="err">&#39;</span><span class="mi">1010</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">y</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span><span class="p">;</span>   <span class="c1">// y == 0b0101&#39;0101;</span>
</code></pre></div>


<h5 id="note_46">Note</h5>
<p>모듈러 연산에서 부호없는 타입은 유용하다.
하지만, 모듈러 연산을 사용하고자 한다면 그 코드가 많은 프로그래머들을 놀라게 할 수 있기 때문에 뒤얽힌 행동에 대해 필요한 만큼 주석을 작성하라.</p>
<h5 id="enforcement_58">Enforcement</h5>
<ul>
<li>표준 라이브러리 내에서 unsigned 타입을 사용하는 것으로 인해 일반적으로 거의 불가능하다</li>
<li>???</li>
</ul>
<h3 id="es102-signed"><a name="Res-signed"></a>ES.102: 연산에는 부호가 있는(signed) 타입을 사용하라</h3>
<h5 id="reason_59">Reason</h5>
<p>대부분의 산술연산(arithmetic)은 부호를 고려한다;
모듈러 연산과 같이 특별한 경우가 아니라면 <code>x - y</code>는 <code>y &gt; x</code>인 경우 음수값이 나오길 기대한다.</p>
<h5 id="example_68">Example</h5>
<p>부호없는 타입을 사용한 산술연산은 기대밖의 결과를 낳는다 (그걸 의도하지 않았다면).
부호 있는 타입과 부호 없는 타입이 섞여서 산술연산에 사용되는 코드 역시 마찬가지다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
    <span class="n">T</span> <span class="n">subtract</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T2</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">us</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">subtract</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>       <span class="c1">// -2</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">subtract</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>     <span class="c1">// 4294967294</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">subtract</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>      <span class="c1">// -2</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">subtract</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>      <span class="c1">// 4294967294</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">subtract</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">us</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>  <span class="c1">// -2</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">subtract</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>  <span class="c1">// 4294967294</span>
    <span class="p">}</span>
</code></pre></div>


<p>이 코드로 어떤 일이 일어나는지 분명히 알 수 있다.
하지만 당신이 <code>us - (s + 2)</code> 혹은 <code>s += 2; ...; us - s</code>같은 코드를 봤다면, 그 결과가 <code>4294967294</code>라고 확신할 수 있었겠는가?</p>
<h5 id="exception_12">Exception</h5>
<p>진정 모듈러 연산이 필요하다면 부호없는 타입을 사용하라 - 그 코드가 많은 프로그래머들을 놀라게 할 수 있기 때문에 뒤얽힌 행동에 대해 필요한 만큼 주석을 작성하라.</p>
<h5 id="example_69">Example</h5>
<p>표준 라이브러리는 배열 원소에 접근할 때 부호없는 타입을 사용한다.
기본적인 배열(built-in array) 타입은 부호있는 타입을 사용한다.
이는 코드가 불가피하게 기대를 벗어나게 (그리고 버그가 생기게) 한다.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="c1">// compares signed to unsigned; some compilers warn, but we should not</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">a2</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>         <span class="c1">// error: negative size</span>

    <span class="c1">// OK, but the number of ints (4294967294) is so large that we should get an exception</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>


<p>배열 접근(subscript)에는 <code>gsl::index</code>를 사용하라; <a href="#Res-subscripts">ES.107를 참고하라</a></p>
<h5 id="enforcement_59">Enforcement</h5>
<ul>
<li>부호 있는 타입과 없는 타입이 섞여서 산술연산에 사용되면 지적하라</li>
<li>부호 없는 타입의 결과가 부호 있는 타입처럼 출력되거나 대입되면 지적하라</li>
<li>부호 없는 타입으로 지정된 리터럴(예를 들어, <code>-2</code>)이 컨테이너 배열 접근에 사용되면 지적하라</li>
<li>(너무 많은 경고를 막기 위해) 비교의 피연산자 중 하나가 <code>sizeof</code> 혹은 컨테이너의 <code>.size()</code>를 사용하고, 다른 한쪽은 <code>ptrdiff_t</code> 경우는 지적하지 마라</li>
</ul>
<h3 id="es103-overflow"><a name="Res-overflow"></a>ES.103: Overflow가 발생하지 않게 하라</h3>
<h5 id="reason_60">Reason</h5>
<p>오버플로우는 수식 알고리즘을 의미없게 만들어 버린다.
최대값 이상으로 증가시킨다면 메모리값이 망가지고 비정상적으로 작동한다.</p>
<h5 id="example-bad_30">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// bad</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="c1">// bad (twice)</span>
</code></pre></div>


<h5 id="example-bad_31">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// bad</span>
</code></pre></div>


<h5 id="example-bad_32">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="mi">10</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">,</span> <span class="mi">100</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">);</span>   <span class="c1">// bad</span>
</code></pre></div>


<h5 id="exception_13">Exception</h5>
<p>모듈러 연산(modulo arithmetic)을 사용한다면 부호없는 타입을 사용하라.</p>
<h5 id="alternative_3">Alternative</h5>
<p>어느 정도의 오버헤드를 감수할 수 있는 대단히 중요한 프로그램에서는 범위 검사를 수행하거나 부동소수점 타입을 사용하라.</p>
<h5 id="enforcement_60">Enforcement</h5>
<p>???</p>
<h3 id="es104-underflow"><a name="Res-underflow"></a>ES.104: Underflow가 발생하지 않게 하라</h3>
<h5 id="reason_61">Reason</h5>
<p>최소값 이하로 값이 내려가면 메모리 값이 망가지고 비정상적으로 작동한다.</p>
<h5 id="example-bad_33">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// bad</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">101</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>   <span class="c1">// bad (twice)</span>
</code></pre></div>


<h5 id="exception_14">Exception</h5>
<p>모듈러 연산(modulo arithmetic)을 사용한다면 부호없는 타입을 사용하라.</p>
<h5 id="enforcement_61">Enforcement</h5>
<p>???</p>
<h3 id="es105-0"><a name="Res-zero"></a>ES.105: 0으로 나누지 않도록 하라</h3>
<h5 id="reason_62">Reason</h5>
<p>결과가 정의되지 않았으며 크래시를 발생시킬 것이다.</p>
<h5 id="note_47">Note</h5>
<p>모듈러 연산(<code>%</code>)에도 적용된다</p>
<h5 id="example-bad_34">Example; bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// BAD, should be checked (e.g., in a precondition)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="example-good_4">Example; good</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">double</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// good, address via precondition (and replace with contracts once C++ gets them)</span>
        <span class="n">Expects</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// good, address via check</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">/</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">quiet_NaN</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div>


<h5 id="alternative_4">Alternative</h5>
<p>어느 정도의 오버헤드를 감수할 수 있는 대단히 중요한 프로그램에서는 범위 검사를 수행하거나 부동소수점 타입을 사용하라.</p>
<h5 id="enforcement_62">Enforcement</h5>
<ul>
<li>0이 될 수 있는 정수로 나눗셈을 할 경우 지적하라</li>
</ul>
<h3 id="es106-unsigned"><a name="Res-nonnegative"></a>ES.106: 음수값을 막으려고 <code>unsigned</code>를 사용하지 마라</h3>
<h5 id="reason_63">Reason</h5>
<p><code>unsigned</code>를 선택하는 것은 정수들의 동작이 달라지게 만든다. 여기에는 모듈러 연산, Overflow 경고, 부호 유무에 의한 오류의 가능성이 포함된다.
<code>unsigned</code>를 사용하는것 자체는 음수가 생길 가능성을 원천봉쇄하지 않는다.</p>
<h5 id="example_70">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>   <span class="c1">// Valid: the value of u1 is 4294967294</span>
    <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span>   <span class="c1">// Valid: the value of u2 is 4294967294</span>
    <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">u2</span><span class="p">;</span>            <span class="c1">// Valid: the value of i2 is -2</span>
</code></pre></div>


<p>예시와 같은 (완전히 합법인) 생성 코드는 실제로는 찾아내기 어렵고 많은 오류의 원인이다.</p>
<p>다음과 같은 코드를 고려해보라:</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">unsigned</span> <span class="nf">area</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">height</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// see also: I.6 사전 조건을 표현하고 싶다면 `Expects()`를 사용하라</span>
        <span class="k">return</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">height</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>   <span class="c1">// if the input is -2 a becomes 4294967292</span>
</code></pre></div>


<p><code>-1</code>이 <code>unsigned int</code>에서는 최대값으로 사용된다는 것을 기억하라.
Also, since unsigned arithmetic is modulo arithmetic the multiplication didn't overflow, it wrapped around.</p>
<h5 id="example_71">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="kt">unsigned</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>    <span class="c1">// &quot;accidental typo&quot;, I mean to say 10&#39;000</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> 
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// infinite loop</span>
</code></pre></div>


<p><code>x</code>가 부호 있는 <code>short</code> 였다면, Overflow에 의한 미정의 행동을 컴파일러가 경고했을 것이다.</p>
<h5 id="alternatives_1">Alternatives</h5>
<ul>
<li>부호 있는 정수들을 사용하고 <code>x &gt;= 0</code>를 검사한다</li>
<li>양의 정수 타입을 사용한다</li>
<li>정수의 부분 타입(subrange type)을 사용한다</li>
<li><code>Assert(-1 &lt; x)</code></li>
</ul>
<p>예를 들자면</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">struct</span> <span class="n">Positive</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">Positive</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span><span class="n">val</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="p">{</span>
            <span class="n">Assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">Positive</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">arg</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// throws</span>
</code></pre></div>


<h5 id="note_48">Note</h5>
<p>???</p>
<h5 id="enforcement_63">Enforcement</h5>
<p>어려움: <code>unsigned</code>를 사용하는 코드는 엄청나게 많고, 실제로 사용 가능한 양수 타입을 제공하지 않는다.</p>
<h3 id="es107-unsigned-gslindex"><a name="Res-subscripts"></a>ES.107: 배열 접근에는 <code>unsigned</code>를 쓰지 말고 <code>gsl::index</code>를 사용하라</h3>
<h5 id="reason_64">Reason</h5>
<p>부호 유무에 따른 혼선을 막는다.
최적화를 돕는다.
오류 탐지를 돕는다.
<code>auto</code>와 <code>int</code>의 함정을 예방한다.</p>
<h5 id="example-bad_35">Example, bad</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>

    <span class="c1">// may not be big enough</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> 
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// risk wraparound</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// may not be big enough</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// verbose</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// bug</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// may not be big enough</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>


<h5 id="example-good_5">Example, good</h5>
<div class="codehilite"><pre><span></span><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>             <span class="c1">// ok</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">)</span>          <span class="c1">// ok</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>


<h5 id="note_49">Note</h5>
<p>기본 배열(built-in array) 타입은 부호 있는 정수를 배열 접근에 사용한다.
표준 라이브러리의 컨테이너들은 부호 없는 정수를 사용한다.
이로 인해 완벽하게 호환되는 해결책은 없다 (표준 라이브러리 컨테이너들이 미래에 부호 있는 정수로 배열 접근을 하지 않는 한).
이와 관련된 문제들로 인해, 충분한 크기를 가진다고 보장하는 <code>gsl::index</code>를 쓰는 것이 더 낫다.</p>
<h5 id="example_72">Example</h5>
<div class="codehilite"><pre><span></span><code>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">My_container</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span><span class="p">);</span>    <span class="c1">// not unsigned</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</code></pre></div>


<h5 id="example_73">Example</h5>
<div class="codehilite"><pre><span></span><code>    ??? demonstrate improved code generation and potential for error detection ???
</code></pre></div>


<h5 id="alternatives_2">Alternatives</h5>
<p>사용자를 위한 대안들</p>
<ul>
<li>표준 라이브러리의 algorithm들을 사용한다</li>
<li>범위 기반 for 문을 사용한다</li>
<li>반복자나 포인터를 사용한다</li>
</ul>
<h5 id="enforcement_64">Enforcement</h5>
<ul>
<li>표준 라이브러리의 컨테이너들이 바뀌지 않는 한 매우 까다롭다</li>
<li>(너무 많은 경고를 막기 위해) 비교의 피연산자 중 하나가 <code>sizeof</code> 혹은 컨테이너의 <code>.size()</code>를 사용하고, 다른 한쪽은 <code>ptrdiff_t</code> 경우는 지적하지 마라</li>
</ul>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Errors/" title="Errors" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Errors
              </div>
            </div>
          </a>
        
        
          <a href="../Functions/" title="Functions" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Functions
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright (c) Standard C++ Foundation and its contributors
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../assets/javascripts/bundle.b39636ac.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.a68abb33.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>